{"meta":{"title":"天网空间","subtitle":null,"description":"新的一天，鑫的一条路。","author":"KAM","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-12-15T14:14:36.000Z","updated":"2019-12-15T09:37:31.903Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"[さくら-天-网-の] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-10-05T09:58:14.438Z","comments":false,"path":"bangumi/index.html","permalink":"http://yoursite.com/bangumi/index.html","excerpt":"","text":""},{"title":"技术栈","date":"2019-12-15T14:14:36.000Z","updated":"2020-10-31T08:36:53.024Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-12-15T09:39:21.482Z","comments":false,"path":"client/index.html","permalink":"http://yoursite.com/client/index.html","excerpt":"","text":"尽请期待："},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-10-05T09:58:14.440Z","comments":true,"path":"comment/index.html","permalink":"http://yoursite.com/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"donate","date":"2019-12-15T15:13:05.000Z","updated":"2019-12-15T09:07:54.462Z","comments":false,"path":"donate/index.html","permalink":"http://yoursite.com/donate/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-08-09T13:30:49.077Z","comments":false,"path":"lab/index.html","permalink":"http://yoursite.com/lab/index.html","excerpt":"","text":"实验室建设中……滴滴滴。。。"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-10-05T09:58:14.443Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-09-12T09:39:18.935Z","comments":false,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-10-05T09:58:14.445Z","comments":true,"path":"rss/index.html","permalink":"http://yoursite.com/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-10-05T09:58:14.446Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"车库","date":"2019-01-04T14:53:25.000Z","updated":"2020-09-12T01:49:39.191Z","comments":false,"path":"the-garage/index.html","permalink":"http://yoursite.com/the-garage/index.html","excerpt":"","text":"个人github，欢迎交流github! 个人只是比较喜欢车，并没有豪车！"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-15T19:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://yoursite.com/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-10-05T09:58:14.448Z","comments":false,"path":"video/index.html","permalink":"http://yoursite.com/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"},{"title":"Mysql查询语句错误","date":"2020-06-22T12:18:02.000Z","updated":"2020-09-12T02:27:21.976Z","comments":true,"path":"categories/DB/Method queryTotal execution error of sql：SELECT COUNT(1)... .html","permalink":"http://yoursite.com/categories/DB/Method%20queryTotal%20execution%20error%20of%20sql%EF%BC%9ASELECT%20COUNT(1)...%20.html","excerpt":"","text":"Method queryTotal execution error of sql：SELECT COUNT(1)…场景：（查询语句）查询**详细信息。 问题分析及解决方案： -分析：查询执行时，将我们的目标查询语句（SELECT id,name…）执行成了SELECT COUNT(1)…。 这种问题一般是自己书写的SQL语句有问题，所以我们要首先定位到自己的SQL语句并仔细检查 -解决排查：一般SQL的错误点： 1、实体类中有code1字段表中没有（反之）。 2、查询字段名称与实体类或表中字段不对应。 3、查询的数据库及表不正确。（查错库和表） 4、SQL语句中的判空、判null、length&gt;0等操作是否严谨。 5、SQL语句是否书写有误等问题。 总结： 一般这种情况，都是SQL语句有错误，导致Mybaits查询不到相应的内容，从而执行了SELECT COUNT(1)…，所以务必要仔细检查SQL查询语句。"},{"title":"Redis缓存穿透、缓存击穿、缓存雪崩","date":"2020-07-08T13:18:08.000Z","updated":"2020-09-12T02:30:40.468Z","comments":true,"path":"categories/DB/Redis缓存穿透、缓存击穿、缓存雪崩.html","permalink":"http://yoursite.com/categories/DB/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9.html","excerpt":"","text":"缓存穿透、缓存击穿、缓存雪崩：缓存穿透：描述：缓存穿透是指缓存和数据库中都查询不到数据。 问题及安全性：访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。如果有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 解决方案： 1、简单粗暴的方法，从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况下也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击； 2、采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤，（如果数据量较大，需要占用较大空间）。 3、拦截器，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截； 缓存击穿：描述：缓存击穿是指缓存中没有数据但数据库中有数据（一般是缓存时间到期）。 问题：如果并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。 解决方案： 1、设置热点数据永远不过期。 2、使用redis的分布式锁，即第一个请求去查询数据库并添加到缓存中，其后面的所有请求只需查询缓存无需查询数据库，从而减少数据库查询的巨大压力。 单机Redis实例: 多个Redis实例，请参阅Redlock算法 注意：1. 设置唯一锁名称防止误解锁；2. 需要设置锁的过期时间，防止死锁。 （1）redisTemplate实现（设置IfAbsent），无法实现可重入锁。 // 根据ID查询商品 @GetMapping(\"/&amp;#123;id&amp;#125;\") public R id(@PathVariable String id)&amp;#123; // 先查Redis缓存 Object o = redisTemplate.opsForValue().get(id); if (o != null) &amp;#123; // 命中缓存 System.err.println(\"id:\"+id+\",命中redis缓存...\"); return R.success(o); &amp;#125; // 缓存未命中 查询数据库 String lockKey = \"lock\" + id; // 加锁，10s后过期 for (;;) &amp;#123; if (redisTemplate.opsForValue().setIfAbsent(lockKey, System.currentTimeMillis(), 10L, TimeUnit.SECONDS)) &amp;#123; // 加锁成功的线程,再次检查 o = redisTemplate.opsForValue().get(id); if (o != null) &amp;#123; // 命中缓存 System.err.println(\"Thread:\" + Thread.currentThread().getName() + \",id:\"+id+\",命中redis缓存...\"); // 释放锁 redisTemplate.delete(lockKey); return R.success(o); &amp;#125; // 仍未命中 System.err.println(\"Thread:\" + Thread.currentThread().getName() + \",id:\" + id + \",查询DB...\"); Goods goods = goodsMapper.selectById(id); // 结果存入Redis redisTemplate.opsForValue().set(id, goods); // 释放锁 redisTemplate.delete(lockKey); return R.success(goods); &amp;#125; // 竞争不到锁，暂时让出CPU资源 Thread.yield(); &amp;#125; &amp;#125; （2）Redisson可实现可重入锁 @RestController public class RedisSonTest &amp;#123; @Autowired RedissonClient redissonClient;//实现分布式锁的 @Autowired RedisUtil redisUtil;//获得redis的链接 @GetMapping(value = \"/redissontest\") public String RedisSonTest()&amp;#123; Jedis jedis = redisUtil.getJedis(); RLock redisSonLock = redissonClient.getLock(\"redisSonLock\"); //加锁 redisSonLock.lock(10, TimeUnit.MINUTES);//有效期十分钟 String k = jedis.get(\"k\"); try &amp;#123; if(k==null)&amp;#123; k = \"1\"; &amp;#125; int inum = Integer.parseInt(k);//获得value的值 jedis.set(\"k\", inum+1+\"\");//value增加1 jedis.close(); &amp;#125;finally &amp;#123; // 解锁 redisSonLock.unlock(); &amp;#125; return k; &amp;#125; &amp;#125; 缓存雪崩：描述：redis中大量的热点数据缓存集体失效。 问题：当有大量请求的时候，就会导致这些请求全部发到数据库上，DB瞬时压力过重雪崩。 解决方案： 1、设置随机过期时间，避免同一时刻缓存大量失效。（当redis数据库崩溃的时候也会导致缓存雪崩） 2、使用google的Guava本地缓存，防止redis崩溃引起的雪崩。（JVM宕机后本地缓存会失效） 3、建立分布式集群： 将redis缓存分块存储到多台redis服务器上（防止单个redis崩溃导致缓存雪崩），这样就会减小缓存集体失效的概率。 4、设置热点数据永远不过期。"},{"title":"redis中BitMap实现“用户签到”、“活跃用户”详解记录","date":"2020-07-15T13:18:08.000Z","updated":"2020-09-12T02:31:37.922Z","comments":true,"path":"categories/DB/redis中BitMap实现“用户签到”、“活跃用户”详解记录.html","permalink":"http://yoursite.com/categories/DB/redis%E4%B8%ADBitMap%E5%AE%9E%E7%8E%B0%E2%80%9C%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0%E2%80%9D%E3%80%81%E2%80%9C%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E2%80%9D%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95.html","excerpt":"","text":"redis中BitMap实现“用户签到”、“活跃用户”详解记录BitMap简介： BitMap是一串连续的二进制数字（0和1），类似于位数组，每一位所在的位置为偏移量（offset），类似于数组索引，BitMap就是通过最小的单位bit来进行0|1的设置，表示某个元素的值或者状态。所以BitMap比较适用于只有两种状态的场景。例如，统计每日活跃用户、统计每月打卡数(签到)等统计场景。1天记录1000W用户的活跃统计数据，只需要10000000/8/1024/1024 ≈1.2M。 优势 1.省空间：基于最小的单位bit进行存储。 2.时间复杂度：赋值-&gt;时间复杂度O(1)、读值-&gt;时间复杂度O(n)，操作是非常快的。 3.计算：二进制数据的存储，进行相关计算的时候非常快。 4.方便扩容 限制 redis中bit映射被限制在512MB之内，所以最大是2^32位。建议每个key的位数都控制下，因为读取时候时间复杂度O(n)，越大的串读的时间花销越多。 一、用户是否领取过优惠券：// redis客户端 Jedis jedis = new Jedis(); // 1.首先检验用户是否领取过优惠券 id:用户id ; couponId:优惠券id ;1:已领取，0：未领取 int isGot = jedis.getbit(couponId, id); if(isGot == 1)&amp;#123; // 已领取 return R.failed(\"您已经领取过此优惠券，不能重复领取！\"); &amp;#125;else&amp;#123; // 未领取 // 查询优惠券剩余数量 CouponEntity coupon = couponService.selectById(couponId); if(coupon.getNum() &lt;= 0)&amp;#123; return R.failed(\"您来晚了，优惠券已经领取完了！\"); &amp;#125; jedis.setbit(couponId, id, 1); // *如需要往数据库记录领取信息* // couponService.insert(); //减去优惠券剩余数量 couponService.deleteNum(couponId); return R.ok(\"已领取！\"); &amp;#125; // 2.统计已领取的优惠券数量 bitcount(key) Integer count = jedis.bitcount(couponId); 二、活跃用户统计// 当天登录及视为活跃 使用时间作为cacheKey，然后用户ID为offset，如果当日活跃过就设置为1 // 在登陆处添加 todayDate:当天时间 id：用户id // 获取当前日期 LocalDate now = LocalDate.now(); jedis.setbit(now, id, 1); // 统计当天活跃用户 jedis.bitcount(now); // 统计某个时间端活跃用户 date1 date2 or:取或 tem：返回值存在tem中，再bitcount计算结果 // AND：与 、OR：或 、NOT：非 、 XOR：异或 jedis.bitop(or, tem, date1, date2); int num = jedis.bitcount(tem); 三、用户签到： /** *譬如 setbit sign:123:1909 0 1 *代表用户ID=123签到，签到的时间是19年9月份，0代表该月第一天，1代表签到了 *第二天没有签到，无需处理，系统默认为0 */ // 获取当前年月日 LocalDate now = LocalDate.now(); int year = now.getYear(); int month = now.getMonthValue(); int day = now.getDayOfMonth(); String key = id+year+month; // 签到 int signIn = jedis.getbit(key, day); if(signIn == 1)&amp;#123; return R.faild(\"您已经签到了，一天只能签到一次！\");// 实际中可以通过前端点击签到按钮置灰，按钮只能点击一次。 &amp;#125;else&amp;#123; jedis.setbit(key, day, 1); &amp;#125; return R.ok(\"签到成功！\"); 以上代码记录紧急，仅供参考！如有错误及不严谨地方，请谅解并留言！"},{"title":"java开发过程中常用的工具类","date":"2020-07-08T13:18:08.000Z","updated":"2020-10-31T08:42:40.136Z","comments":true,"path":"categories/Java/Java常用工具类.html","permalink":"http://yoursite.com/categories/Java/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB.html","excerpt":"","text":"工具类： java开发过程中常用的工具类，可以省去很多的无用功。如：MD5加密、String相关操作/判null，“”、集合操作等等…请前往一下网站查看，这里不做赘述。 官网地址：http://www.hutool.cn/"},{"title":"POI千万级导入-导出(excel)","date":"2019-11-20T13:18:08.000Z","updated":"2020-09-12T02:29:09.986Z","comments":true,"path":"categories/Java/POI千万级导入-导出Excel.html","permalink":"http://yoursite.com/categories/Java/POI%E5%8D%83%E4%B8%87%E7%BA%A7%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BAExcel.html","excerpt":"","text":"POI千万级导入-导出(excel)前端采用LayUi框架 ，后端框架：SpringBoot 一 。 导出1.引入 &lt;dependency> &lt;groupId>org.apache.poi&lt;/groupId> &lt;artifactId>poi&lt;/artifactId> &lt;version>3.17&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.poi&lt;/groupId> &lt;artifactId>poi-ooxml&lt;/artifactId> &lt;version>3.17&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.poi&lt;/groupId> &lt;artifactId>poi-ooxml-schemas&lt;/artifactId> &lt;version>3.14&lt;/version> &lt;/dependency> 2.Controller代码 /** * 导出数据到Excel表格 * @param response * @param * @throws IOException */ @RequestMapping(value = \"export\") @ResponseBody public void export(HttpServletResponse response,GradeEntity gradeEntity) throws IOException &amp;#123; //查询数据 Integer id = gradeEntity.getId(); Map&lt;String ,Object> map = new HashMap&lt;>(); map.put(\"id\",id); List&lt;GradeEntity> gradeList = gradeService.selectLists(map); HSSFWorkbook wb = new HSSFWorkbook();//创建工作簿 HSSFWorkbook:Excel的文档对象 HSSFFont font = wb.createFont();//设置字体大小 为什么要用wb.createFont呢 因为wb是主 font是包含这个里面的 HSSFCellStyle style = wb.createCellStyle(); //设置单元格格式 style.setAlignment(HorizontalAlignment.CENTER);//居中对齐格式 style.setVerticalAlignment(VerticalAlignment.CENTER);//垂直居中 font.setFontHeightInPoints((short) 28);//设置字体 HSSFSheet sheet = wb.createSheet(\"等级信息表\");// //为每一列添加居中样式 sheet.setDefaultColumnStyle(0,style); sheet.setDefaultColumnStyle(1,style); sheet.setDefaultColumnStyle(2,style); sheet.setDefaultColumnStyle(3,style); sheet.setDefaultColumnStyle(4,style); sheet.setDefaultColumnStyle(5,style); sheet.setDefaultColumnStyle(6,style); HSSFRow row = null; //创建行 row = sheet.createRow(0);//创建第一行单元格.就像数组一样是0开头的 row.setHeight((short) (26.5 * 20));//设置行高 row.createCell(0).setCellValue(\"等级信息表\"); //设置第一行单元格设置值 HSSFPatriarch patr = sheet.createDrawingPatriarch();//HSSFPatriarch poi的划线方法 HSSFComment comment = patr.createComment(new HSSFClientAnchor(0, 0, 0, 0, (short) 4, 2, (short) 6, 5)); // 设置注释内容 comment.setString(new HSSFRichTextString(\"状态 0：关闭，1：开启！\")); //设置单元格合并 参数是：起始行号，终止行号， 起始列号，终止列号 CellRangeAddress rowRegion = new CellRangeAddress(0, 0, 0, 2); sheet.addMergedRegion(rowRegion); //sheet是页 这个的意思在文档Sheet的第一行 row = sheet.createRow(1); /* row.setHeight((short) (22.50 * 20));*/ //设置单元格格式 row.setHeight((short) (20.29 * 20)); //第一行标签 row.createCell(0).setCellValue(\"编号\"); row.createCell(1).setCellValue(\"等级名称\"); row.createCell(2).setCellValue(\"等级图标\"); row.createCell(3).setCellValue(\"等级值\"); row.createCell(4).setCellValue(\"等级\"); row.createCell(5).setCellValue(\"排序\"); row.createCell(6).setCellValue(\"状态\"); //遍历集合数据，产生数据行 for (int i = 0; i &lt; gradeList.size(); i++) &amp;#123; row = sheet.createRow(i + 2); GradeEntity grade = gradeList.get(i); //往表格添加数据 row.createCell(0).setCellValue(grade.getId()); row.createCell(1).setCellValue(grade.getName()); row.createCell(2).setCellValue(grade.getIcon()); row.createCell(3).setCellValue(grade.getIntegral()); row.createCell(4).setCellValue(grade.getGrade()); row.createCell(5).setCellValue(grade.getSort()); row.createCell(6).setCellValue(grade.getStatus()); //日期格式化 /* SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String time = sdf.format(userInfo1.getCreateDate()); row.createCell(6).setCellValue(time);*/ //状态处理 数据库存放的是0,1 我写的麻烦 你们自己处理吧 Integer status = grade.getStatus(); String status1 = null; if (status == 0) &amp;#123; status1 = \"关闭\"; row.createCell(6).setCellValue(status1); &amp;#125; else &amp;#123; row.createCell(6).setCellValue(\"开启\"); &amp;#125; &amp;#125; sheet.setDefaultRowHeight((short) (20.29 * 20)); for (int i = 0; i &lt;= 6; i++) &amp;#123; sheet.autoSizeColumn(i);//自动行高 &amp;#125; response.setContentType(\"UTF-8\"); //设置格式为UTF-8 不然可能会乱码 response.setContentType(\"application/vnd.ms-excel;charset=utf-8\"); //output流得到流 OutputStream os = response.getOutputStream(); String fileName = \"用户报名信息\";//导出得文件名字 String downloadFileName=new String(fileName.getBytes(\"utf-8\"),\"iso8859-1\"); response.setHeader(\"Content-Disposition\", \"attachment;filename=\"+downloadFileName+\".xls\"); wb.write(os); os.flush();//刷新流 os.close();//关闭流 &amp;#125; 3.layui前端按钮（其他按钮自定） &lt;script type=\"text/html\" id=\"tableBar\"> @if(shiro.hasPermission(\"/grade/update\"))&amp;#123; &lt;a class=\"layui-btn layui-btn-primary layui-btn-xs\" lay-event=\"edit\">修改&lt;/a> @&amp;#125; @if(shiro.hasPermission(\"/grade/delete\"))&amp;#123; &lt;a class=\"layui-btn layui-btn-danger layui-btn-xs\" lay-event=\"delete\">删除&lt;/a> @&amp;#125; &lt;a class=\"layui-btn layui-btn-danger layui-btn-xs\" lay-event=\"export\" href=\"/grade/export\" >导出&lt;/a> &lt;/script> @&amp;#125; 二.导入Excel 到数据库—————-Controller代码： /** * 导入数据到数据库 * * @param request * @param * @throws IOException */ @RequestMapping(value = \"/import\") @ResponseBody public GradeEntity imports(MultipartFile file, HttpServletRequest request) throws IOException &amp;#123; GradeEntity grade= new GradeEntity(); try &amp;#123; /*List&lt;GradeEntity> typeLists = new ArrayList&lt;GradeEntity>();*/ //使用POI解析Excel文件 //如果是xls，使用HSSFWorkbook；2003年的excel 如果是xlsx，使用XSSFWorkbook 2007年excel HSSFWorkbook workbook = new HSSFWorkbook(file.getInputStream()); //前台传过来的文件 /*HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(ResourceUtils.getFile(\"F:/import.xls\")));*/ //写死的路径 //根据名称获得指定Sheet对象 HSSFSheet hssfSheet = workbook.getSheetAt(0); for (Row row : hssfSheet) &amp;#123; int rowNum = row.getRowNum(); if (rowNum == 0) &amp;#123;//跳出第一行 一般第一行都是表头没有数据意义 continue; &amp;#125; //编号 if (row.getCell(0) != null) &amp;#123;//第1列数据 row.getCell(0).setCellType(CellType.STRING); grade.setId(Integer.parseInt(row.getCell(0).getStringCellValue())); &amp;#125; //等级名称 if (row.getCell(1) != null) &amp;#123;//第2列 row.getCell(1).setCellType(CellType.STRING); grade.setName(row.getCell(1).getStringCellValue()); &amp;#125; //等级图标 if (row.getCell(2) != null) &amp;#123;//第3列 row.getCell(2).setCellType(CellType.STRING); grade.setIcon(row.getCell(2).getStringCellValue()); &amp;#125; //等级值 // 转换为Integer类 if (row.getCell(3) != null) &amp;#123;//第4列 row.getCell(3).setCellType(CellType.STRING); grade.setIntegral(Integer.parseInt(row.getCell(3).getStringCellValue())); &amp;#125; /*// 转换为日期类型 if(row.getCell(4)!=null)&amp;#123;//第5列 row.getCell(4).setCellType(Cell.CELL_TYPE_NUMERIC); grade.setAddtime( HSSFDateUtil.getJavaDate(row.getCell(4).getNumericCellValue())); &amp;#125;*/ //等级 if (row.getCell(4) != null) &amp;#123;//第5列 row.getCell(4).setCellType(CellType.STRING); grade.setGrade(Integer.parseInt(row.getCell(4).getStringCellValue())); &amp;#125; //排序 if (row.getCell(5) != null) &amp;#123;//第6列 row.getCell(5).setCellType(CellType.STRING); grade.setSort(Integer.parseInt(row.getCell(5).getStringCellValue())); &amp;#125; //状态 if (row.getCell(6) != null) &amp;#123;//第7列 row.getCell(6).setCellType(CellType.STRING); if (\"开启\".equals(grade.getSort())) &amp;#123; grade.setStatus(1); &amp;#125; else &amp;#123; grade.setStatus(0); &amp;#125; &amp;#125; /* typeLists.add(grade);*/ //调用service执行保存typeLists的方法 gradeService.insert(grade);//添加每一条数据 &amp;#125; &amp;#125; catch (Exception e) &amp;#123; e.printStackTrace(); &amp;#125; return grade;//使用layui前端上传文件 所以需要返回一个值（也可不返回，依照前端而定） &amp;#125; ———-layui前端实现：JS代码： //导入Excel upload.render(&amp;#123; elem: '#import' , url: \"/grade/import\" ,accept: 'file' ,exts: 'xls|xlsx' //只允许上传Excel文件 ,done: function(res)&amp;#123; alert(\"导入成功！\") //刷新表格 tableResult.reload(); &amp;#125; &amp;#125;); HTMl代码： &lt;div class=\" layui-upload\"> &lt;button type=\"button\" class=\"layui-btn layui-btn-normal\" id=\"import\">导入&lt;/button>&lt;!--导入Excel--> &lt;/div>"},{"title":"Stream流相关操作","date":"2020-08-20T13:00:08.000Z","updated":"2020-09-12T02:38:13.263Z","comments":true,"path":"categories/Java/Stream流相关操作.html","permalink":"http://yoursite.com/categories/Java/Stream%E6%B5%81%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.html","excerpt":"","text":"Stream流相关操作Stream流一、Stream的中间操作 distinct()：去重```javaUser.Stream().distinct() filter：过滤```javastudents.stream().filter(student -&gt; “清华大学”.equals(student.getSchool())).collect(Collectors.toList()); limit：limit操作也类似于SQL语句中的LIMIT关键字，不过相对功能较弱，limit返回包含前n个元素的流，当集合大小小于n时，则返回实际长度。```javastudents.stream().filter(student -&gt; “计算机”.equals(student.getMajor())).limit(2).collect(Collectors.toList()); .sorted() ：排序```java// 状态排序orderListDTOS.stream().sorted(Comparator.comparing(OrderListDTO::getOrderStatusStr) // 评价时间 为null靠前 .thenComparing(OrderListDTO::getEvaluateTime, Comparator.nullsFirst(String::compareTo).reversed()) // 下单时间 倒序 .thenComparing(OrderListDTO::getOrderTime, Comparator.nullsFirst(String::compareTo)).reversed()) // 赋值给新集合 进行保存 .collect(Collectors.toList()).forEach(order -&gt; &#123; OrderListDTO orderListDTO = new OrderListDTO(); BeanUtils.copyProperties(order, orderListDTO); orders.add(orderListDTO); &#125;); skip：是跳过前n个元素```javastudents.stream().filter(student -&gt; “计算机科学”.equals(student.getMajor())).skip(2) of：实现判断```javaString status = pouch.getStatus();if (Stream.of( &quot;Finalized&quot;, &quot;Ready&quot;, &quot;Checkout&quot;, &quot;Confirmed&quot;, &quot;Book&quot;, &quot;Started&quot;, &quot;Inital&quot;, &quot;Close&quot;) .anyMatch(status::equals)) &#123;// anyMatch：检测是否存在一个或多个满足指定的参数行为 // 逻辑代码块} 二、终端操作：2.1 查找： allMatch：allMatch用于检测是否全部都满足指定的参数行为，如果全部满足则返回true，如下：学生年龄是否大于等于18。```javaboolean isAdult = students.stream().allMatch(student -&gt; student.getAge() &gt;= 18); anyMatch：anyMatch则是检测是否存在一个或多个满足指定的参数行为，如果满足则返回true，如下：所有学生中是否有清华大学的学生。```javaboolean hasWhu = students.stream().anyMatch(student -&gt; “清华大学”.equals(student.getSchool())); noneMathch：noneMatch用于检测是否不存在满足指定行为的元素，如果不存在则返回true，如下：检测是否不存在专业为计算机科学的学生。```javaboolean noneCs = students.stream().noneMatch(student -&gt; “计算机科学”.equals(student.getMajor())); findFirst：用于返回满足条件的第一个元素```javastudents.stream().filter(student -&gt; “计算机科学”.equals(student.getMajor())).findFirst(); findAny：相对于findFirst的区别在于，findAny不一定返回第一个，而是返回任意一个```javastudents.stream().filter(student -&gt; “计算机”.equals(student.getMajor())).findAny(); &gt; 实际上对于顺序流式处理而言，findFirst和findAny返回的结果是一样的，至于为什么会这样设计，是因为在下一篇我们介绍的**并行流式处理**，当我们启用并行流式处理的时候，查找第一个元素往往会有很多限制，如果不是特别需求，在**并行流式处理中使用findAny的性能要比findFirst好**。 2.2 归约： 我们大部分都是通过collect(Collectors.toList())对数据封装返回，如我的目标不是返回一个新的集合，而是希望对经过参数化操作后的集合进行进一步的运算，那么我们可用对集合实施归约操作。java8的流式处理提供了reduce方法来达到这一目的。 前面我们通过mapToInt将Stream&lt;Student&gt;映射成为IntStream，并通过IntStream的sum方法求得所有学生的年龄之和，实际上我们通过归约操作，也可以达到这一目的，实现如下： ​```java// 前面例子中的方法int totalAge = students.stream() .filter(student -&gt; “计算机科学”.equals(student.getMajor())) .mapToInt(Student::getAge).sum();// 归约操作int totalAge = students.stream() .filter(student -&gt; “计算机科学”.equals(student.getMajor())) .map(Student::getAge) .reduce(0, (a, b) -&gt; a + b); // 进一步简化int totalAge2 = students.stream() .filter(student -&gt; “计算机科学”.equals(student.getMajor())) .map(Student::getAge) .reduce(0, Integer::sum); // 采用无初始值的重载版本，需要注意返回OptionalOptional totalAge = students.stream() .filter(student -&gt; “计算机科学”.equals(student.getMajor())) .map(Student::getAge) .reduce(Integer::sum); // 去掉初始值 **2.3 收集：** 前面利用**`collect(Collectors.toList())`是一个简单的收集操作，是对处理结果的封装**，对应的还有**`toSet`、`toMap`**，以满足我们对于结果组织的需求。这些方法均来自于`java.util.stream.Collectors`，我们可以称之为收集器。 **2.3.1 规约：** &gt; **收集器也提供了相应的归约操作**，但是与reduce在内部实现上是有区别的**，收集器更加适用于可变容器上的归约操作**，这些收集器广义上均基于**`Collectors.reducing()`**实现。 (1). 求学生总数：**.count()、Collectors.counting()** ```java long count = students.stream().collect(Collectors.counting()); // 进一步简化 long count = students.stream().count();(2). 求最大值和最小值：Collectors.maxBy、Collectors.minBy // 求最大年龄 Optional&lt;Student> olderStudent = students.stream().collect(Collectors.maxBy((s1, s2) -> s1.getAge() - s2.getAge())); // 进一步简化 Optional&lt;Student> olderStudent2 = students.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge))); // 求最小年龄 Optional&lt;Student> olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge))); (3). 求总和：Collectors.summingInt int totalAge4 = students.stream().collect(Collectors.summingInt(Student::getAge)); // 对应的还有summingLong、summingDouble。 求平均值：**Collectors.averagingInt**double avgAge = students.stream().collect(Collectors.averagingInt(Student::getAge)); // 对应的还有averagingLong、averagingDouble。 一次性得到元素个数、总和、均值、最大值、最小值:IntSummaryStatistics statistics = students.stream().collect(Collectors.summarizingInt(Student::getAge)); // 输出： IntSummaryStatistics&amp;#123;count=10, sum=220, min=20, average=22.000000, max=24&amp;#125; 对应的还有summarizingLong、summarizingDouble… (4). 字符串拼接 : Collectors.joining(“”) String names = students.stream().map(Student::getName).collect(Collectors.joining()); // 输出：孔明伯约玄德云长翼德元直奉孝仲谋鲁肃丁奉 String names = students.stream().map(Student::getName).collect(Collectors.joining(\", \")); // 输出：孔明, 伯约, 玄德, 云长, 翼德, 元直, 奉孝, 仲谋, 鲁肃, 丁奉 2.3.2 分组： 在数据库操作中，我们可以通过GROUP BY关键字对查询到的数据进行分组，java8的流式处理也为我们提供了这样的功能Collectors.groupingBy来操作集合： students.stream().collect( Collectors.groupingBy(Student::getSchool, // 一级分组，按学校 Collectors.groupingBy(Student::getMajor))); // 二级分组，按专业 实际上在groupingBy的第二个参数不是只能传递groupingBy，还可以传递任意Collector类型，比如我们可以传递一个Collector.counting，用以统计每个组的个数： Map&lt;String, Long> groups = students.stream().collect(Collectors.groupingBy(Student::getSchool, Collectors.counting())); 如果我们不添加第二个参数，则编译器会默认帮我们添加一个Collectors.toList()。 2.3.3 分区： 分区可以看做是分组的一种特殊情况，在分区中key只有两种情况：true或false，目的是将待分区集合按照条件一分为二，处理利用collectors.partitioningBy()方法实现分区，该方法接收一个谓词，例如我们希望将学生分为武大学生和非武大学生，那么可以实现如下： Map&lt;Boolean, List&lt;Student>> partition = students.stream().collect(Collectors.partitioningBy(student -> \"武汉大学\".equals(student.getSchool()))); 例如：比如将数组分为奇数和偶数。 三、parallelStream（并行流，相比于Stream更快但是涉及到线程安全）list.parallelStream().map(e -&gt; e + 3).collect(Collectors.toList()); parallelStream在处理大的数据量的集合时使用，但是线程不安全，可以先map，再.collect(Collectors.toList()，.collect(Collectors.toList()可以封装一个List集合返回，还可以保证线程安全。 ——-错误记录：——- 1、Collectors.toMap value为null报错 Map&lt;String, Integer> map3 = new HashMap&lt;>(0); map3 = list3.stream().collect(Collectors.toMap( list3 -> Optional.ofNullable(list3).map(SpGoodsIdAndCount::getGoodsId).orElse(\"\") , list3 -> Optional.ofNullable(list3).map(SpGoodsIdAndCount::getCount).orElse(0) , (key1, key2) -> key2)); 解析：Collectors.toMap(）：list集合转换为map，通过Optional判断当key和value为null时赋予默认值。(key1, key2) -&gt; key2)：当key重复时，选择key2作为新的key值。"},{"title":"feign调用异常：Method has too many Body parameters","date":"2020-07-22T12:08:18.000Z","updated":"2020-09-12T02:24:50.160Z","comments":true,"path":"categories/Java/feign调用异常：java.lang.IllegalStateException_ Method has too many Body parameters.html","permalink":"http://yoursite.com/categories/Java/feign%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8%EF%BC%9Ajava.lang.IllegalStateException_%20Method%20has%20too%20many%20Body%20parameters.html","excerpt":"","text":"java.lang.IllegalStateException: Method has too many Body parametersfeign调用异常：Method has too many Body parameters 解决方法：所有参数必须加上注解 @RequestMapping(value = \"/spCommodity/commodityPage\", method = RequestMethod.POST) R goodsList(Page page, @RequestBody CommodityListQO commodityListQO);// 会报错 get请求：参数要加上注解@RequestParam post请求：只能有一个@RequestBody，Page属于一个对象，可删除，其余的参数需要加上@RequestParam feign调用的接口处可修改： @PostMapping(\"/commodityPage\") public R goodsList(@RequestBody CommodityListQO commodityListQO)&amp;#123; Page&lt;SpServiceCommodity> page = new Page&lt;>(); // 页数 page.setCurrent(commodityListQO.getCurrent()); // 每页显示条数 page.setSize(commodityListQO.getSize());"},{"title":"java中使用@Value获取值为null问题解决","date":"2020-08-19T15:08:10.000Z","updated":"2020-09-12T02:46:02.750Z","comments":true,"path":"categories/Java/java中使用@Value获取值为null问题解决.html","permalink":"http://yoursite.com/categories/Java/java%E4%B8%AD%E4%BD%BF%E7%94%A8@Value%E8%8E%B7%E5%8F%96%E5%80%BC%E4%B8%BAnull%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html","excerpt":"","text":"java中使用@Value获取值为null问题解决：问题重现：读取配置文件(**.yml)中的值，获取为null // 读取配置文件(**.yml)中的值 @Value(value = \"$&amp;#123;upload.minio.minio_url&amp;#125;\") private static String minioUrl; 问题解析： java中static/final修饰的变量，通过@Value是获取不到值的。 问题解决方案： 方案一：在变量的*seter方法上使用@Value * 1.静态变量的setter 方法需要去掉 static 修饰词， 2.并需要使用public修饰， 3.最后需要注意要*在类上加上@Component *，才可以成功注入。 @Value(value = \"$&amp;#123;upload.minio.minio_url&amp;#125;\") public static void setMinioUrl(String minioUrl) &amp;#123; MinioUtil.minioUrl = minioUrl; &amp;#125; 方案二：通过中间变量赋值：*在类上加上@Component * private static String minioUrl; @Value(value = \"$&amp;#123;upload.minio.minio_url&amp;#125;\") private String minioUrl2; @PostConstruct public void init() &amp;#123; minioUrl = minioUrl2; &amp;#125; 总结： 解决方案有两种，都是间接的通过非static的变量获取到值，从而拿到.yml中的值；但是，两种方法中都需要在类上加上@Component。"},{"title":"minio搭建上传图片(文件)使用教程（在docker中创建）","date":"2020-07-20T13:18:08.000Z","updated":"2020-09-12T02:27:54.101Z","comments":true,"path":"categories/Java/minio搭建上传图片(文件)使用教程（在docker中创建）.html","permalink":"http://yoursite.com/categories/Java/minio%E6%90%AD%E5%BB%BA%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87(%E6%96%87%E4%BB%B6)%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E5%9C%A8docker%E4%B8%AD%E5%88%9B%E5%BB%BA%EF%BC%89.html","excerpt":"","text":"minio搭建上传图片(文件)使用教程（在docker中创建）： 使用服务器CentOS 7.0，版本：3.10.0-1127.10.1.el7.x86_64 一、查看服务器版本（使用minio版本好像需要在3.0.xx以上，其他版本请自行测试）：uname -r 二、安装docker容器。（其他安装方法请百度）2.1：安装yum源 yum install -y epel-release 2.2：通过yum安装docker容器 yum install docker-io 2.3：查看docker版本, 确定是否安装成功 docker version 三、创建文件在服务器上的存储路径：(可以自行命名创建) chmod 777 /home/data/minio/data (设置文件夹最高权限：777读写执行) mkdir -p /home/data/minio/data mkdir -p /home/data/minio/config chmod 777 /home/data/minio/data 四、在docker中创建minio MINIO_ACCESS_KEY，MINIO_SECRET_KEY：请自行设置（便于记忆） docker run -p 9000:9000 -e MINIO_ACCESS_KEY=MINIO_TEST_ADMIN -e MINIO_SECRET_KEY=123456 -v /data:/data minio/minio server /data _出现如下信息则证明成功，_可通过：http://服务器ip:9000进行访问。 You are running an older version of MinIO released 1 day ago Update: docker pull minio/minio:RELEASE.2020-08-27T05-16-20Z Endpoint: http://***.**.**.**:9000 http://127.0.0.1:9000 Browser Access: http://***.**.**.**:9000 http://127.0.0.1:9000 Object API (Amazon S3 compatible): Go: https://docs.min.io/docs/golang-client-quickstart-guide Java: https://docs.min.io/docs/java-client-quickstart-guide Python: https://docs.min.io/docs/python-client-quickstart-guide JavaScript: https://docs.min.io/docs/javascript-client-quickstart-guide .NET: https://docs.min.io/docs/dotnet-client-quickstart-guide 查看启动结果： docker ps -a"},{"title":"request.getParameter(&quot;**&quot;)获取不到值","date":"2020-08-08T13:18:08.000Z","updated":"2020-09-12T02:37:37.393Z","comments":true,"path":"categories/Java/request.getParameter(____)获取不到值.html","permalink":"http://yoursite.com/categories/Java/request.getParameter(____)%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%80%BC.html","excerpt":"","text":"request.getParameter(&quot;**&quot;)获取不到值：需求场景： 上传图片功能中，为了更好的维护图片，要求前端在请求中传递一个路径参数。 问题解析： 归根结底就是HTML中的form表单有一个关键属性enctype＝application/x-www-form-urlencoded导致的。 request.getParameter(“…”)在enctype＝application/x-www-form-urlencoded配置下可以获取到值。由于需求场景是上传文件，所以前端请求过来的是：multipart/form-data，导致request.getParameter(“…”)获取不到值。 解决方案：通过request.getInputStream()、request.getReader(）替换request.getParameter() 一、request.getInputStream() 二、request.getReader(“前端放在请求头中参数名称”) 总结：我是采用第二种直接获取请求头中的参数，第一种未测试。"},{"title":"二叉树、平衡二叉树、红黑树、B树、B+树","date":"2019-12-20T13:13:48.000Z","updated":"2020-09-12T02:39:39.632Z","comments":true,"path":"categories/Java/二叉树-平衡二叉树-红黑树-B树-B+树.html","permalink":"http://yoursite.com/categories/Java/%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91-B%E6%A0%91-B+%E6%A0%91.html","excerpt":"​ 数据库中的数据一般是放在磁盘里面，存取数据的时候就要访问磁盘，物理访问过程：盘片旋转，磁臂移动 两个过程。盘片旋转到指定位置之后，移动磁臂开始进行数据的存取。如果使用顺序查找，查询数据的时候就要从头到尾查询一遍，如果所查询的数据靠近数据尾端，效率久会很低，当然，这种方式也是最低效率的。因此，出现了二叉树。","text":"​ 数据库中的数据一般是放在磁盘里面，存取数据的时候就要访问磁盘，物理访问过程：盘片旋转，磁臂移动 两个过程。盘片旋转到指定位置之后，移动磁臂开始进行数据的存取。如果使用顺序查找，查询数据的时候就要从头到尾查询一遍，如果所查询的数据靠近数据尾端，效率久会很低，当然，这种方式也是最低效率的。因此，出现了二叉树。 二叉树二叉树是一种非常重要的数据结构，它同时具有数组和链表各自的特点：它可以像数组一样快速查找，也可以像链表一样快速添加。但是它也有自己的缺点：删除操作复杂。 二叉树在插入数据时也存在一个很大的缺点： 在使用二叉树插入节点时：一个节点的左节点的关键值必须小于此节点，右节点必须大于或者等于此节点。 通过上面定义可以发现：如果插入的数据是有序的，二叉树就会形成一个分支的树结构，远远增加了树的深度。因而为了提高效率稳定性，形成了平衡二叉树： 平衡二叉树：平衡二叉树用平衡因子差值来判断是否平衡，并旋转二叉树。平衡因子：左右子树高度差。平衡二叉树里平衡因子不能超过1，否则旋转。缺点：平衡二叉树虽然达到了稳定，但是由于不停的旋转，时间方面浪费了很多，从而效率又降了下来。 那么怎样才能稳定的同时，旋转的次数少？ 再次升级–&gt;红黑树 红黑树：定义： 1、每个节点要么是红色，要么是黑色。 2、根节点必须是黑色。 3、红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。 4、对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。 红黑树旋转的关键逻辑是：确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。例如：节点A，左子树高度X，右子树高度Y， X-Y&lt;=min(X,Y);如果当 X-Y &gt; min(X,Y)，然后开始旋转。 在java中TreeSet的数据结构底层就是用的红黑树 红黑树虽然解决了稳定、时间浪费的问题，但是，我们一开始就说了，数据库中的数据一般是存在磁盘上的，如果考虑到磁盘IO的影响，当数据量过大，就有可能不能一次性读取到内存中；反复的从磁盘到内存，效率就又会降低！ 读取磁盘次数过多，读取浪费就太多，这也是MySql不使用红黑树作为索引的原因 B树多路存储能力 考虑到磁盘IO,内存的影响，所以产生了B树。B树：每个节点上都存有key和value，所以每次读取数据时，只需把相应的节点读取到内存中即可，而不需把整个树都读取到内存。等价于有关键字的二分查找，所以B树解决了红黑树存在的问题。 问题：B树虽然解决了磁盘读取到内存效率降低的问题，但是由于B树的每一个节点上都存有数据，那么就会造成空间浪费，范围查找还是没有解决。那应该怎么解决呢?再次升级–&gt;B+树！ B+树：B+树中所有的数据都存在叶子节点中，并且叶子节点中还加了指针形成了链表，其他的都是索引，增加了系统的稳定性以及遍历以及查找效率。 MySql索引采用B+树 为什么MySql中索引采用B+树？ 通过应用场景，我们可以知道。再通过MySql查询数据时，我们通常查询的不只是一条数据，大多数情况下都是多条数据。如果采用B树，查询多条时，可能需要跨层获取数据，所以，B+树中叶子节点之间增加了指针形成了链表结构，查询多条数据时更加的快速，因此MySql中索引采用了B+树，提高了效率！ hash比B+树更快，为什么MySql没有采用hash? 如果查询一条数据的话，hash确实比B+树快。但是正如我们上面所说，我们查询数据时通常是多条的，这时候由于B+树索引有序并且还有链表相连，而且数据库中的索引一般在磁盘，数据量大的时候，B+树可以允许数据分批，同时树的高度比较低，也提高了查询效率，所以多数据时B+树会更快。"},{"title":"微信小程序 订阅消息","date":"2020-02-18T13:30:18.000Z","updated":"2020-09-12T02:40:24.850Z","comments":true,"path":"categories/Java/微信小程序-订阅消息.html","permalink":"http://yoursite.com/categories/Java/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF.html","excerpt":"","text":"微信小程序 订阅消息使用说明： 步骤一：获取模板 ID，登陆 微信公众平台 步骤二：发送消息用户必须授权。获取下发权限，详见小程序端消息订阅接口 wx.requestSubscribeMessage 步骤三： 1、拿到用户的opengId 2、获取access_token 3、调用接口下发订阅消息，详见服务端消息发送接口 subscribeMessage.send 一、发送模板消息所需字段： 二、必须获得access_token： 通俗的讲，access_token就是小程序官方给我们提供的一个凭证，你要调用小程序官方的接口，就必须先拿到access_token。 看下官方文档，可以知道我们需要用到下面的几个参数 获取access_token方法 @GetMapping(\"/getAccessToken\") public static String getAccessToken() &amp;#123; RestTemplate restTemplate = new RestTemplate(); Map&lt;String, String> params = new HashMap&lt;>(16); params.put(\"APPID\", \"wxc36f8fe5f4c70fa2\"); params.put(\"APPSECRET\", \"acc4380705c716611a7d1ff690ac21f0\"); ResponseEntity&lt;String> responseEntity = restTemplate.getForEntity( \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&amp;#123;APPID&amp;#125;&amp;secret=&amp;#123;APPSECRET&amp;#125;\", String.class, params); String body = responseEntity.getBody(); JSONObject object = JSON.parseObject(body); String Access_Token = object.getString(\"access_token\"); String expires_in = object.getString(\"expires_in\"); System.out.println(\"有效时长expires_in：\" + expires_in); return Access_Token; &amp;#125; 注意点：access_token，是存在有效期的 三、发送消息到小程序 推送代码： @RestController public class SendWxMessage &amp;#123; public static void main(String[] args) &amp;#123; String openid = \"o8MPr4oEWfgIM5IvMq9jZ2eUHA4g\"; SendWxMessage.push(openid); &amp;#125; /** * 发送订阅 * @return */ public static String push(String openid) &amp;#123; RestTemplate restTemplate = new RestTemplate(); // 这里简单起见我们每次都获取最新的access_token（时间开发中，应该在access_token快过期时再重新获取） String url = \"https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=\" + getAccessToken(); // 拼接推送的模版 WxMssVo wxMssVo = new WxMssVo(); // 用户的openid（要发送给那个用户，通常这里应该动态传进来的） wxMssVo.setTouser(openid); // 订阅消息模板id wxMssVo.setTemplate_id(\"W4TH5pcWj_UtPOhEYWmcvow2Xyyp3SNJyxyA39S9MO0\"); wxMssVo.setPage(\"pages/index/index\"); // 24小时制 Date date = new Date(); SimpleDateFormat format=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Map&lt;String, TemplateData> m = new HashMap&lt;>(16); // 以下所有的key名称必须与定义的模板的key名称相同 且value类型必须一致 m.put(\"thing1\", new TemplateData(\"小程序\")); m.put(\"time2\", new TemplateData(format.format(date))); m.put(\"thing4\", new TemplateData(\"888\")); m.put(\"number3\", new TemplateData(123.0)); wxMssVo.setData(m); ResponseEntity&lt;String> responseEntity = restTemplate.postForEntity(url, wxMssVo, String.class); return responseEntity.getBody(); &amp;#125; /** * 获取access_token */ @GetMapping(\"/getAccessToken\") public static String getAccessToken() &amp;#123; RestTemplate restTemplate = new RestTemplate(); Map&lt;String, String> params = new HashMap&lt;>(16); params.put(\"APPID\", \"wxc36f8fe5f4c70fa2\"); params.put(\"APPSECRET\", \"acc4380705c716611a7d1ff690ac21f0\"); ResponseEntity&lt;String> responseEntity = restTemplate.getForEntity( \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid= &amp;#123;APPID&amp;#125;&amp;secret=&amp;#123;APPSECRET&amp;#125;\", String.class, params); String body = responseEntity.getBody(); JSONObject object = JSON.parseObject(body); String Access_Token = object.getString(\"access_token\"); String expires_in = object.getString(\"expires_in\"); System.out.println(\"有效时长expires_in：\" + expires_in); return Access_Token; &amp;#125; &amp;#125; 注意点：Map&lt;String, TemplateData&gt;所有的key名称必须与定义的模板的key名称相同 且value类型必须一致 订阅消息参数值内容限制说明，文档里的参数值个数有12个 参考地址：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html 其余代码： WxMssVo类用来封装请求官方接口的参数 public class WxMssVo &amp;#123; private String touser;//用户openid private String template_id;//订阅消息模版id private String page = \"pages/index/index\";//默认跳到小程序首页 private Map&lt;String, TemplateData> data;//推送文字 public String getTouser() &amp;#123; return touser; &amp;#125; public void setTouser(String touser) &amp;#123; this.touser = touser; &amp;#125; public String getTemplate_id() &amp;#123; return template_id; &amp;#125; public void setTemplate_id(String template_id) &amp;#123; this.template_id = template_id; &amp;#125; public String getPage() &amp;#123; return page; &amp;#125; public void setPage(String page) &amp;#123; this.page = page; &amp;#125; public Map&lt;String, TemplateData> getData() &amp;#123; return data; &amp;#125; public void setData(Map&lt;String, TemplateData> data) &amp;#123; this.data = data; &amp;#125; &amp;#125; TemplateData类 用来定义消息的内容 public class TemplateData &amp;#123; private Object value; public TemplateData(Object value) &amp;#123; this.value = value; &amp;#125; public Object getValue() &amp;#123; return value; &amp;#125; public void setValue(Object value) &amp;#123; this.value = value; &amp;#125; &amp;#125;"},{"title":"百度富文本-Vue UEditor整合","date":"2020-02-20T13:15:00.000Z","updated":"2020-09-12T08:15:43.163Z","comments":true,"path":"categories/前端/百度富文本UEditor在vue中的整合.html","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/%E7%99%BE%E5%BA%A6%E5%AF%8C%E6%96%87%E6%9C%ACUEditor%E5%9C%A8vue%E4%B8%AD%E7%9A%84%E6%95%B4%E5%90%88.html","excerpt":"","text":"百度富文本 vue UEditor 整合查看文档请转移至：百度富文本-Vue的整合"},{"title":"关于\"栈上分配\"和\"TLAB(Thread Local Allocation Buffer 即线程本地分配缓存)\"","date":"2020-03-03T13:40:45.000Z","updated":"2020-09-12T02:40:58.967Z","comments":true,"path":"categories/Java/栈上分配和TLAB.html","permalink":"http://yoursite.com/categories/Java/%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%92%8CTLAB.html","excerpt":"","text":"栈上分配：为什么要栈上分配？ 在一个应用程序中，其实有很多的对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束。对于这种对象，如果分配在堆中，方法调用结束后就没有了引用指向这个对象，这种对象就是垃圾，等待GC回收，如果这种对象较多，无疑增加了GC的压力，所以JVM就提供了一种栈上分配。 开启逃逸分析： 如果一个对象想要在栈上分配，必须通过逃逸分析(-XX:+EliminateAllocations)。 逃逸分析的作用：分析对象的作用域是否会逃逸出方法之外，再server虚拟机模式下才可以开启（jdk1.6默认开启） 开启标量替换： (-XX:+EliminateAllocations) 标量替换的作用是允许将对象根据属性打散后分配再栈上，默认该配置为开启 可以通过配置 -XX:+PrintEscapeAnalysis 开启打印逃逸分析筛选结果 TLAB(Thread Local Allocation Buffer)什么是TLAB 全称叫做：Thread Local Allocation Buffer 即线程本地分配缓存 如何开启TLAB JVM默认开启了TLAB功能，也可以使用-XX: +UseTLAB 显示开启 如何观察TLAB使用情况 JVM提供了-XX:+PrintTLAB 参数打开跟踪TLAB的使用情况 如何调整TLAB默认大小 -XX:TLABSize 通过该参数指定分配给每一个线程的TLAB空间的大小 总结一下TLAB： 需要TLAB的原因就是提高对象在堆上的分配效率而采用的一种手段，就是给每个线程分配一小块私有的堆空间，即TLAB是一块线程私有的堆空间（实际上是Eden区中划出的） 栈上分配和TLAB对比 名称 针对点 处于对象分配流程的位置 栈上分配 避免GC无谓负担 1 TLAB 加速堆上对象的分配 2 对象分配流程图图片摘自实战Java虚拟机一书"},{"title":"Mysql调优详解","date":"2020-09-01T13:18:08.000Z","updated":"2020-09-12T02:28:31.310Z","comments":true,"path":"categories/DB/Mysql调优详解.html","permalink":"http://yoursite.com/categories/DB/Mysql%E8%B0%83%E4%BC%98%E8%AF%A6%E8%A7%A3.html","excerpt":"","text":"Mysql调优详解 查询返回多条数据多列合并 一、GROUP_CONCAT([DISTINCT]要连接的字段 [Order BY 排序字段 ASC/DESC] [Separator ‘分隔符’])—–à默认使用逗号分隔，支持多个列拼接在一行展示。 语法： GROUP_CONCAT(str1,str2,..., Order BY ASC/DESC, SEPARATOR ',') 二、CONCAT_WS（separator,str1,str2,……） 将多个列使用指定字符串进行拼接成一个字符串返回。与CONCAT（str1,str2,str3,……）的区别，当CONCAT函数中返回的任意一个字段的值为NULL时，则整个返回结果就为NULL，而当CONCAT_WS函数中任意一个字段的值为NULL时，则会自动忽略此列的值进行拼接；当CONCAT函数中返回的任意一个字段的值为’ ’时，则返回结果会将空白项拼接在字符串中返回。 语法： CONCAT_WS(separator,str1,str2,……) SQL语句优化策略： .避免全表扫描对查询进行优化，应尽量避免全表扫描，首先应考虑在where 及order by 涉及的列上建立索引。 当有一批处理的插入或更新时，用批量插入或批量更新（Mybatis-plus也支持批量插入/更新），绝不会一条条记录的去更新! 查询语法中的字段任何地方都不要使用select _ from t_ ，用具体的字段列表代替“”，不要返回用不到的任何字段。 联表查询优化：多张数据表查询数据，使用inner join，left/right join来代替子查询，可以提高查询的效率。join : （阿里规约不要超过联接5个表查询）&gt; inner join其返回的结果为被连接的两个数据表的乘积，因此当有WHERE, ON或USING条件的时候一般不建议使用，因为当数据表项目太多的时候，会非常慢。一般使用LEFT [OUTER] JOIN或者RIGHT [OUTER] JOIN ORDER BY 排序注意字段类型（正常情况下排序字段为数字类型）数字 类型：order by 字段 排序方式字符串类型：order by cast(字段 as char)字符串 类型的数字：1：order by (字段+0) 排序方式 2： order by cast(字段 as unsigned)枚举类型：默认是按照枚举的下标排序的，如果想按照字符串排序跟字符串排序是一样的使用按照指定的数据方式排序：order by field(字段,’排序值’,’排序值’,’’) 解释：排序值可以一只加，第一个是字段就好，排序值可以是空，但是排序值相同时，按照找的第一个json类型：order by cast(JSON_EXTRACT(json字段, ‘$.json字段属性名’) as 序号类型) 注：序号类型unsigned(数字) char(字符串) json类型排序在5.7中才有效例如:有字段parame 的json字段 json里面有id,sex,hobbyorder by cast(JSON_EXTRACT(parame ,’$.id’) as unsigned) 使用表的别名(Alias)：当在SQL语句中连接多个表时,请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误。别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。 .避免判断null 值应尽量避免在where 子句中对字段进行null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num 上设置默认值0，确保表中num 列没有null 值，然后这样查询：select id from t where num=0 .避免不等值判断应尽量避免在where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。 尽量使用“&gt;=”，不要使用“&gt;”。 .避免使用or 逻辑应尽量避免在where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20可以这样查询：select id from t where num=10union allselect id from t where num=20&gt; 用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关,如果查询需要用到联合索引，用UNION all执行的效率更高.多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。 .慎用in 和not in 逻辑in 和not in 也要慎用，否则会导致全表扫描，如：select id from t1 where num in(select id from t2 where id &gt; 10)此时外层查询会全表扫描，不使用索引。可以修改为：select id from t1,(select id from t1 where id &gt; 10)t2 where t1.id = t2.id此时索引被使用，可以明显提升查询效率。 如果使用in：在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。 between 代替 in在连续数值的查询中，能使用between的情况下，尽量使用between，而不使用in。in和not in都会导致全表查询。 .注意模糊查询like&gt; 在使用like进行数据表的查询时，能用单%的情况下，不建议使用双%，双%查询会导致mysql引擎放弃使用索引而进行全表扫描查询。 下面的查询也将导致全表扫描：select id from t where name like ‘%abc%’模糊查询如果是必要条件时，可以使用select id from t where name like ‘abc%’来实现模糊查询，此时索引将被使用。如果头匹配是必要逻辑，建议使用：1、全文搜索引擎（Elastic search、Lucene、Solr 等）2、使用mysql5.5以后的虚拟字段，实现统一前缀，来达到使用索引的目的。 避免查询条件中字段计算应尽量避免在where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为:select id from t where num=100*2 避免查询条件中对字段进行函数操作应尽量避免在where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’–name 以abc 开头的id应改为:select id from t where name like ‘abc%’ WHERE 子句“=”左边注意点不要在where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 组合索引使用在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致（最左匹配原则）。 不要定义无异议的查询不要写一些没有意义的查询，如需要生成一个空表结构：select col1,col2 into #t from t where 1=0这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：create table #t(…) exists1、很多时候用exists 代替in 是一个好的选择：select num from a where num in(select num from b)用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)2、使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用 索引也可能失效并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段sex，male、female 几乎各一半，那么即使在sex 上建了索引也对查询效率起不了作用。 使用 “explain” 对SQL语句进行分析，从而使SQL语句使用到索引！ 表格字段类型选择 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先可变长度字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 尽量用union all 代替 union&gt; union 是对数据进行并集操作，不包括重复行，同时进行默认排序 union all 是对数据进行并集操作，包括重复行，不进行排序 union 和 union all 的差异主要是前者需要将两个（或者多个）接过集 合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟，所以当我们可以确认结果集或者不在乎重复结果集的时候，尽量使用union all 而不是 union。 索引无关优化不使用、尽量不使用union，union all 等关键字、尽量不使用or 关键字、尽量使用等值判断。表连接建议不超过5 个。如果超过5 个，则考虑表格的设计。*（互联网应用中）表连接方式使用外联优于内联。外连接有基础数据存在。如：A left join B,基础数据是A。A inner join B，没有基础数据的，先使用笛卡尔积完成全连接，在根据连接条件得到内连接结果集。大数据量级的表格做分页查询时，如果页码数量过大，则使用子查询配合完成分页逻辑**。Select * from table limit 1000000, 10Select * from table where id in (select pk from table limit100000, 10) 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。阿里规约一个表的索引数最好不要超过5个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。避免频繁创建和删除临时表，以减少系统表资源的消耗。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 29.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 30.尽量避免大事务操作，提高系统并发能力。 MySQL优化器可优化的SQL类型&gt; 重新定义表的关联顺序 将外连接转换成内连接使用等价变换规则优化count()、min()和max()将一个表达式转化为常数表达式使用等价变换规则子查询优化提前终止查询对in()条件进行优化 *选择最有效率的表名顺序(只在基于规则的优化器中有效)： *oracle 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表. *提高GROUP BY语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果，但第二个明显就快了许多. *低效:SELECT JOB , AVG(SAL)FROM EMPGROUP BY JOBHAVING JOB =’PRESIDENT’OR JOB =’MANAGER’高效:SELECT JOB , AVG(SAL)FROM EMPWHERE JOB =’PRESIDENT’OR JOB =’MANAGER’GROUP BY JOB sql语句用大写，因为oracle/MySql 总是先解析sql语句，把小写的字母转换成大写的再执行。 查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格(因为，查询缓冲并不自动截取首尾空格)。 避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序;事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量;永远不要在事务中等待用户输入。 避免使用临时表（tag：视图），除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替;大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。 EXPLAIN SELECT 查询用来跟踪查看效果使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等。 *选择表合适存储引擎： *（使用最多的是Innodb） myisam: 应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。*Innodb： *事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（Innodb有效地降低删除和更新导致的锁定）。对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行sql前调用begin，多条sql形成一个事物（即使autocommit打开也可以），将大大提高性能。 索引创建规则：·表的主键、外键必须有索引；·经常与其他表进行连接的表，在连接字段上应该建立索引；·经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；·索引应该建在选择性高的字段上；·索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；（可用搜索引擎ES）· **复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；**·正确选择复合索引中的主列字段，一般是选择性较好的字段；·复合索引的几个字段是否经常同时以 “AND” 方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；·如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；·如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；·如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；·频繁进行数据操作的表，不要建立太多的索引；·删除无用的索引，避免对执行计划造成负面影响；·表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。·尽量不要对数据库中某个含有大量重复的值的字段建立索引。·在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE, GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单,不在多个索引中包含同一个列，有时候MySQL会使用错误的索引,对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。 优化表的数据类型,选择合适的数据类型：（建表时）原则：更小通常更好，简单就好，所有字段都得有默认值,尽量避免null。 **例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型.(mediumint就比int更合适)比如时间字段：datetime和timestamp, datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。**应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。 任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。 更多优化策略后期会持续更新此文章！"},{"title":"java上传图片(文件)到minio/oss/local本地","date":"2020-07-20T13:18:08.000Z","updated":"2020-09-12T02:26:08.214Z","comments":true,"path":"categories/Java/java上传图片(文件)到minio_oss_local本地.html","permalink":"http://yoursite.com/categories/Java/java%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87(%E6%96%87%E4%BB%B6)%E5%88%B0minio_oss_local%E6%9C%AC%E5%9C%B0.html","excerpt":"","text":"java上传图片(文件)到minio/oss/local本地：代码文件已放在了Github：Github地址 以下代码较多，请根据自己需要，选取相应位置代码使用！minio、oss相关maven引入，我并没有贴出，请自行引入(只针对不熟悉minio和oss)。 一、Controller类代码：简介： 接口可以上传图片到minio、oss、local本地（一般windows服务使用）。1、minio在CentOS 7.0 中的搭建使用，请访问：minio搭建使用。2、alioss 存储的相关配置，请访问官网：阿里云OSS 具体代码如下： 请根据自己业务需求进行修改 /** * 文件上传 * @Author hfx */ @Slf4j @RestController @RequestMapping(\"/uploadCommon\") public class CommonController &amp;#123; @Autowired(required = false) private ISysBaseAPI sysBaseAPI; @Value(value = \"$&amp;#123;upload.path.upload&amp;#125;\") private String uploadpath; /** * 本地：local minio：minio 阿里：alioss */ @Value(value=\"$&amp;#123;upload.uploadType&amp;#125;\") private String uploadType; /** * 文件上传统一方法 * @param request * @param response * @return */ @PostMapping(value = \"/upload\") public R&lt;?> upload(HttpServletRequest request, HttpServletResponse response) throws IOException &amp;#123; log.info(\"上传路径uploadpath:&amp;#123;&amp;#125;\", uploadpath); log.info(\"上传类型uploadType:&amp;#123;&amp;#125;\", uploadType); R result = new R(); String savePath = \"\"; // String bizPath = request.getParameter(\"path\"); String bizPath = request.getHeader(\"path\"); log.info(\"bizPath:&amp;#123;&amp;#125;\", bizPath); MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request; MultipartFile file = multipartRequest.getFile(\"file\");// 获取上传文件对象 if(StrUtil.isEmpty(bizPath))&amp;#123; if(Constants.UPLOAD_TYPE_OSS.equals(uploadType))&amp;#123; //未指定目录，则用阿里云默认目录 upload ,使用阿里云文件上传时，必须添加目录！ bizPath = \"upload\"; &amp;#125;else&amp;#123; bizPath = \"didiDefaultFile\"; &amp;#125; &amp;#125; log.info(\"文件目录为path:&amp;#123;&amp;#125;\", bizPath); if(Constants.UPLOAD_TYPE_LOCAL.equals(uploadType))&amp;#123; //针对jeditor编辑器如何使 lcaol模式，采用 base64格式存储 String jeditor = request.getParameter(\"jeditor\"); if(StrUtil.isNotEmpty(jeditor))&amp;#123; result.setMsg(Constants.UPLOAD_TYPE_LOCAL); result.setData(Constants.UPLOAD_TYPE_LOCAL); result.setCode(0); return result; &amp;#125;else&amp;#123; savePath = this.uploadLocal(file,bizPath); &amp;#125; &amp;#125;else&amp;#123; savePath = sysBaseAPI.upload(file,bizPath,uploadType); &amp;#125; if(StrUtil.isNotEmpty(savePath))&amp;#123; result.setData(savePath); result.setCode(0); &amp;#125;else &amp;#123; result.setMsg(\"上传失败！\"); result.setCode(1); &amp;#125; return result; &amp;#125; /** * 本地文件上传 * @param mf 文件 * @param bizPath 自定义路径 * @return */ private String uploadLocal(MultipartFile mf, String bizPath)&amp;#123; try &amp;#123; String ctxPath = uploadpath; String fileName = null; File file = new File(ctxPath + File.separator + bizPath + File.separator ); if (!file.exists()) &amp;#123; file.mkdirs();// 创建文件根目录 &amp;#125; String orgName = mf.getOriginalFilename();// 获取文件名 orgName = CommonUtils.getFileName(orgName); if(orgName.indexOf(\".\")!=-1)&amp;#123; fileName = orgName.substring(0, orgName.lastIndexOf(\".\")) + \"_\" + System.currentTimeMillis() + orgName.substring(orgName.indexOf(\".\")); &amp;#125;else&amp;#123; fileName = orgName+ \"_\" + System.currentTimeMillis(); &amp;#125; String savePath = file.getPath() + File.separator + fileName; File savefile = new File(savePath); FileCopyUtils.copy(mf.getBytes(), savefile); String dbpath = null; if(StrUtil.isNotEmpty(bizPath))&amp;#123; dbpath = bizPath + File.separator + fileName; &amp;#125;else&amp;#123; dbpath = fileName; &amp;#125; if (dbpath.contains(\"\\\\\")) &amp;#123; dbpath = dbpath.replace(\"\\\\\", \"/\"); &amp;#125; return dbpath; &amp;#125; catch (IOException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; return \"\"; &amp;#125; /** * 删除图片 * @return */ @DeleteMapping(value = \"/deleteImg\") public R&lt;?> deleteImg(@RequestBody DeleteQO deleteQO) &amp;#123; // // 是否有需要删除的图片 // if (CollUtil.isEmpty(preDelImg)) // return R.ok(\"没有需要删除的图片！\"); // Collection&lt;String> preDelColl = new ArrayList&lt;>(preDelImg); // boolean delImg = preDelColl.removeAll(preSaveImg); List&lt;Object> preDelImg = deleteQO.getPreDelImg(); String relativePath = deleteQO.getRelativePath(); if (CollUtil.isNotEmpty(preDelImg)) &amp;#123; preDelImg.stream().forEach(img -> &amp;#123; log.info(\"删除的图片为：img:&amp;#123;&amp;#125;\", img); img = relativePath + \"/\" + StrUtil.subAfter((String)img, \"/\", true); sysBaseAPI.delImg(uploadType, (String) img); &amp;#125;); return R.ok(\"已删除图片:\" + preDelImg); &amp;#125; return R.ok(\"没有需要删除的新图片！\"); &amp;#125; &amp;#125; 二、CommonUtils类代码：（主要是处理文件名中的特殊符号）public class CommonUtils &amp;#123; /** * 判断文件名是否带盘符，重新处理 * @param fileName * @return */ public static String getFileName(String fileName)&amp;#123; //判断是否带有盘符信息 // Check for Unix-style path int unixSep = fileName.lastIndexOf('/'); // Check for Windows-style path int winSep = fileName.lastIndexOf('\\\\'); // Cut off at latest possible point int pos = (winSep > unixSep ? winSep : unixSep); if (pos != -1) &amp;#123; // Any sort of path separator found... fileName = fileName.substring(pos + 1); &amp;#125; //替换上传文件名字的特殊字符 fileName = fileName.replace(\"=\",\"\").replace(\",\",\"\").replace(\"&amp;\",\"\"); return fileName; &amp;#125; &amp;#125; 三、MinioUtil工具类（Minio上传、删除相关方法）/** * minio文件上传工具类 */ @Slf4j @Component public class MinioUtil &amp;#123; private static String minioUrl; private static String minioName; private static String minioPass; private static String bucketName; @Value(value = \"$&amp;#123;upload.minio.minio_url&amp;#125;\") public void setMinioUrl(String minioUrl) &amp;#123; MinioUtil.minioUrl = minioUrl; &amp;#125; @Value(value = \"$&amp;#123;upload.minio.minio_name&amp;#125;\") public void setMinioName(String minioName) &amp;#123; MinioUtil.minioName = minioName; &amp;#125; @Value(value = \"$&amp;#123;upload.minio.minio_pass&amp;#125;\") public void setMinioPass(String minioPass) &amp;#123; MinioUtil.minioPass = minioPass; &amp;#125; @Value(value = \"$&amp;#123;upload.minio.bucketName&amp;#125;\") public void setBucketName(String bucketName) &amp;#123; MinioUtil.bucketName = bucketName; &amp;#125; public static String getMinioUrl() &amp;#123; return minioUrl; &amp;#125; public static String getBucketName() &amp;#123; return bucketName; &amp;#125; private static MinioClient minioClient = null; /** * 上传文件 * @param file * @return */ public static String upload(MultipartFile file, String bizPath, String customBucket) &amp;#123; log.info(\"minio相关配置：minio_url:&amp;#123;&amp;#125;, minio_name:&amp;#123;&amp;#125;, minio_pass:&amp;#123;&amp;#125;, bucketName:&amp;#123;&amp;#125;\", minioUrl, minioName, minioPass, bucketName); String file_url = \"\"; String newBucket = bucketName; if(StrUtil.isNotEmpty(customBucket))&amp;#123; newBucket = customBucket; &amp;#125; try &amp;#123; initMinio(minioUrl, minioName,minioPass); // 检查存储桶是否已经存在 if(minioClient.bucketExists(newBucket)) &amp;#123; log.info(\"Bucket already exists.\"); &amp;#125; else &amp;#123; // 创建一个名为ota的存储桶 minioClient.makeBucket(newBucket); log.info(\"create a new bucket.\"); &amp;#125; InputStream stream = file.getInputStream(); // 获取文件名 String orgName = file.getOriginalFilename(); orgName = CommonUtils.getFileName(orgName); String objectName = bizPath+\"/\"+orgName.substring(0, orgName.lastIndexOf(\".\")) + \"_\" + System.currentTimeMillis() + orgName.substring(orgName.indexOf(\".\")); // 使用putObject上传一个本地文件到存储桶中。 minioClient.putObject(newBucket,objectName, stream, (long) stream.available(), null, null, \"application/octet-stream\"); stream.close(); file_url = minioUrl+newBucket+\"/\"+objectName; &amp;#125;catch (IOException e)&amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InvalidKeyException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (NoSuchAlgorithmException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (NoResponseException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (XmlPullParserException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InvalidArgumentException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (RegionConflictException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InvalidBucketNameException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (ErrorResponseException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InternalException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InsufficientDataException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InvalidResponseException e) &amp;#123; e.printStackTrace(); &amp;#125; return file_url; &amp;#125; /** * 文件上传 * @param file * @param bizPath * @return */ public static String upload(MultipartFile file, String bizPath) &amp;#123; return upload(file,bizPath,null); &amp;#125; /** * 获取文件流 * @param bucketName * @param objectName * @return */ public static InputStream getMinioFile(String bucketName,String objectName)&amp;#123; InputStream inputStream = null; try &amp;#123; initMinio(minioUrl, minioName, minioPass); inputStream = minioClient.getObject(bucketName, objectName); &amp;#125; catch (Exception e) &amp;#123; log.info(\"文件获取失败\" + e.getMessage()); &amp;#125; return inputStream; &amp;#125; /** * 删除文件 * @param bucketName * @param objectName * @throws Exception */ public static void removeObject(String bucketName, String objectName) &amp;#123; try &amp;#123; initMinio(minioUrl, minioName,minioPass); minioClient.removeObject(bucketName, objectName); &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件删除失败\" + e.getMessage()); &amp;#125; &amp;#125; /** * 获取文件外链 * @param bucketName * @param objectName * @param expires * @return */ public static String getObjectURL(String bucketName, String objectName, Integer expires) &amp;#123; initMinio(minioUrl, minioName,minioPass); try&amp;#123; String url = minioClient.presignedGetObject(bucketName, objectName, expires); return URLDecoder.decode(url,\"UTF-8\"); &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件路径获取失败\" + e.getMessage()); &amp;#125; return null; &amp;#125; /** * 初始化客户端 * @param minioUrl * @param minioName * @param minioPass * @return */ private static MinioClient initMinio(String minioUrl, String minioName,String minioPass) &amp;#123; if (minioClient == null) &amp;#123; try &amp;#123; minioClient = new MinioClient(minioUrl, minioName,minioPass); &amp;#125; catch (InvalidEndpointException e) &amp;#123; e.printStackTrace(); &amp;#125; catch (InvalidPortException e) &amp;#123; e.printStackTrace(); &amp;#125; &amp;#125; return minioClient; &amp;#125; /** * 上传文件到minio * @param stream * @param relativePath * @return */ public static String upload(InputStream stream,String relativePath) throws IOException, InvalidKeyException, NoSuchAlgorithmException, InsufficientDataException, InternalException, NoResponseException, InvalidBucketNameException, XmlPullParserException, ErrorResponseException, RegionConflictException, InvalidArgumentException, InvalidResponseException &amp;#123; initMinio(minioUrl, minioName,minioPass); if(minioClient.bucketExists(bucketName)) &amp;#123; log.info(\"Bucket already exists.\"); &amp;#125; else &amp;#123; // 创建一个名为ota的存储桶 minioClient.makeBucket(bucketName); log.info(\"create a new bucket.\"); &amp;#125; minioClient.putObject(bucketName,relativePath, stream, (long) stream.available(), null, null, \"application/octet-stream\"); stream.close(); return minioUrl+bucketName+\"/\"+relativePath; &amp;#125; &amp;#125; 四、OssBootUtil工具类（OSS上传、删除相关方法）/** * 阿里云 oss 上传工具类 */ @Slf4j @Component public class OssBootUtil&amp;#123; private static String endPoint; private static String accessKeyId; private static String accessKeySecret; private static String bucketName; private static String staticDomain; @Value(value = \"$&amp;#123;upload.oss.endpoint&amp;#125;\") public void setEndPoint(String endPoint) &amp;#123; OssBootUtil.endPoint = endPoint; &amp;#125; @Value(value = \"$&amp;#123;upload.oss.accessKey&amp;#125;\") public void setAccessKeyId(String accessKeyId) &amp;#123; OssBootUtil.accessKeyId = accessKeyId; &amp;#125; @Value(value = \"$&amp;#123;upload.oss.secretKey&amp;#125;\") public void setAccessKeySecret(String accessKeySecret) &amp;#123; OssBootUtil.accessKeySecret = accessKeySecret; &amp;#125; @Value(value = \"$&amp;#123;upload.oss.bucketName&amp;#125;\") public void setBucketName(String bucketName) &amp;#123; OssBootUtil.bucketName = bucketName; &amp;#125; // @Value(value = \"$&amp;#123;upload.oss.staticDomain&amp;#125;\") public void setStaticDomain(String staticDomain) &amp;#123; OssBootUtil.staticDomain = staticDomain; &amp;#125; /** * oss 工具客户端 */ private static OSSClient ossClient = null; /** * 上传文件至阿里云 OSS * 文件上传成功,返回文件完整访问路径 * 文件上传失败,返回 null * * @param file 待上传文件 * @param fileDir 文件保存目录 * @return oss 中的相对文件路径 */ public static String upload(MultipartFile file, String fileDir, String customBucket) &amp;#123; log.info(\"oss配置信息：enPoint:&amp;#123;&amp;#125;,accessKeyId:&amp;#123;&amp;#125;,accessKeySecret:&amp;#123;&amp;#125;,bucketName:&amp;#123;&amp;#125;,staticDomain:&amp;#123;&amp;#125;\", endPoint, accessKeyId, accessKeySecret, bucketName, staticDomain); String FILE_URL = null; initOSS(endPoint, accessKeyId, accessKeySecret); StringBuilder fileUrl = new StringBuilder(); String newBucket = bucketName; if(StrUtil.isNotEmpty(customBucket))&amp;#123; newBucket = customBucket; &amp;#125; try &amp;#123; //判断桶是否存在,不存在则创建桶 if(!ossClient.doesBucketExist(newBucket))&amp;#123; ossClient.createBucket(newBucket); &amp;#125; // 获取文件名 String orgName = file.getOriginalFilename(); orgName = CommonUtils.getFileName(orgName); String fileName = orgName.substring(0, orgName.lastIndexOf(\".\")) + \"_\" + System.currentTimeMillis() + orgName.substring(orgName.indexOf(\".\")); if (!fileDir.endsWith(\"/\")) &amp;#123; fileDir = fileDir.concat(\"/\"); &amp;#125; fileUrl = fileUrl.append(fileDir + fileName); if (StrUtil.isNotEmpty(staticDomain) &amp;&amp; staticDomain.toLowerCase().startsWith(\"http\")) &amp;#123; FILE_URL = staticDomain + \"/\" + fileUrl; &amp;#125; else &amp;#123; FILE_URL = \"https://\" + newBucket + \".\" + endPoint + \"/\" + fileUrl; &amp;#125; PutObjectResult result = ossClient.putObject(newBucket, fileUrl.toString(), file.getInputStream()); // 设置权限(公开读) // ossClient.setBucketAcl(newBucket, CannedAccessControlList.PublicRead); if (result != null) &amp;#123; log.info(\"------OSS文件上传成功------\" + fileUrl); &amp;#125; &amp;#125; catch (IOException e) &amp;#123; e.printStackTrace(); return null; &amp;#125; return FILE_URL; &amp;#125; /** * 文件上传 * @param file * @param fileDir * @return */ public static String upload(MultipartFile file, String fileDir) &amp;#123; return upload(file, fileDir,null); &amp;#125; /** * 上传文件至阿里云 OSS * 文件上传成功,返回文件完整访问路径 * 文件上传失败,返回 null * * @param file 待上传文件 * @param fileDir 文件保存目录 * @return oss 中的相对文件路径 */ public static String upload(FileItemStream file, String fileDir) &amp;#123; String FILE_URL = null; initOSS(endPoint, accessKeyId, accessKeySecret); StringBuilder fileUrl = new StringBuilder(); try &amp;#123; String suffix = file.getName().substring(file.getName().lastIndexOf('.')); String fileName = UUID.randomUUID().toString().replace(\"-\", \"\") + suffix; if (!fileDir.endsWith(\"/\")) &amp;#123; fileDir = fileDir.concat(\"/\"); &amp;#125; fileUrl = fileUrl.append(fileDir + fileName); if (StrUtil.isNotEmpty(staticDomain) &amp;&amp; staticDomain.toLowerCase().startsWith(\"http\")) &amp;#123; FILE_URL = staticDomain + \"/\" + fileUrl; &amp;#125; else &amp;#123; FILE_URL = \"https://\" + bucketName + \".\" + endPoint + \"/\" + fileUrl; &amp;#125; PutObjectResult result = ossClient.putObject(bucketName, fileUrl.toString(), file.openStream()); // 设置权限(公开读) ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead); if (result != null) &amp;#123; log.info(\"------OSS文件上传成功------\" + fileUrl); &amp;#125; &amp;#125; catch (IOException e) &amp;#123; e.printStackTrace(); return null; &amp;#125; return FILE_URL; &amp;#125; /** * 删除文件 * @param url */ public static void deleteUrl(String url) &amp;#123; deleteUrl(url,null); &amp;#125; /** * 删除文件 * @param url */ public static void deleteUrl(String url,String bucket) &amp;#123; String newBucket = bucketName; if(StrUtil.isNotEmpty(bucket))&amp;#123; newBucket = bucket; &amp;#125; String bucketUrl = \"\"; if (StrUtil.isNotEmpty(staticDomain) &amp;&amp; staticDomain.toLowerCase().startsWith(\"http\")) &amp;#123; bucketUrl = staticDomain + \"/\" ; &amp;#125; else &amp;#123; bucketUrl = \"https://\" + newBucket + \".\" + endPoint + \"/\"; &amp;#125; url = url.replace(bucketUrl,\"\"); ossClient.deleteObject(newBucket, url); &amp;#125; /** * 删除文件 * @param fileName */ public static void delete(String fileName) &amp;#123; ossClient.deleteObject(bucketName, fileName); &amp;#125; /** * 获取文件流 * @param objectName * @param bucket * @return */ public static InputStream getOssFile(String objectName,String bucket)&amp;#123; InputStream inputStream = null; try&amp;#123; String newBucket = bucketName; if(StrUtil.isNotEmpty(bucket))&amp;#123; newBucket = bucket; &amp;#125; initOSS(endPoint, accessKeyId, accessKeySecret); OSSObject ossObject = ossClient.getObject(newBucket,objectName); inputStream = new BufferedInputStream(ossObject.getObjectContent()); &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件获取失败\" + e.getMessage()); &amp;#125; return inputStream; &amp;#125; /** * 获取文件流 * @param objectName * @return */ public static InputStream getOssFile(String objectName)&amp;#123; return getOssFile(objectName,null); &amp;#125; /** * 获取文件外链 * @param bucketName * @param objectName * @param expires * @return */ public static String getObjectURL(String bucketName, String objectName, Date expires) &amp;#123; initOSS(endPoint, accessKeyId, accessKeySecret); try&amp;#123; if(ossClient.doesObjectExist(bucketName,objectName))&amp;#123; URL url = ossClient.generatePresignedUrl(bucketName,objectName,expires); return URLDecoder.decode(url.toString(),\"UTF-8\"); &amp;#125; &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件路径获取失败\" + e.getMessage()); &amp;#125; return null; &amp;#125; /** * 初始化 oss 客户端 * * @return */ private static OSSClient initOSS(String endpoint, String accessKeyId, String accessKeySecret) &amp;#123; if (ossClient == null) &amp;#123; ossClient = new OSSClient(endpoint, new DefaultCredentialProvider(accessKeyId, accessKeySecret), new ClientConfiguration()); &amp;#125; return ossClient; &amp;#125; /** * 上传文件到oss * @param stream * @param relativePath * @return */ public static String upload(InputStream stream, String relativePath) &amp;#123; String FILE_URL = null; String fileUrl = relativePath; initOSS(endPoint, accessKeyId, accessKeySecret); if (StrUtil.isNotEmpty(staticDomain) &amp;&amp; staticDomain.toLowerCase().startsWith(\"http\")) &amp;#123; FILE_URL = staticDomain + \"/\" + relativePath; &amp;#125; else &amp;#123; FILE_URL = \"https://\" + bucketName + \".\" + endPoint + \"/\" + fileUrl; &amp;#125; PutObjectResult result = ossClient.putObject(bucketName, fileUrl.toString(),stream); // 设置权限(公开读) ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead); if (result != null) &amp;#123; log.info(\"------OSS文件上传成功------\" + fileUrl); &amp;#125; return FILE_URL; &amp;#125; &amp;#125; 五、共同业务API: SysBaseApiImpl、ISysBaseAPI/** * @Description: 底层共通业务API，提供其他独立模块调用 * @Author: hfx * @Version:V1.0 */ @Slf4j @Service @Component public class SysBaseApiImpl implements ISysBaseAPI &amp;#123; /** 当前系统数据库类型 */ private static String DB_TYPE = \"\"; /** * minio桶名称 */ private static String miniBucketName; @Value(value = \"$&amp;#123;upload.minio.bucketName&amp;#125;\") public void setMiniBucketName(String miniBucketName) &amp;#123; SysBaseApiImpl.miniBucketName = miniBucketName; &amp;#125; private static String ossBucketName; @Value(value = \"$&amp;#123;upload.oss.bucketName&amp;#125;\") public void setOssBucketName(String ossBucketName) &amp;#123; SysBaseApiImpl.ossBucketName = ossBucketName; &amp;#125; @Override public String upload(MultipartFile file, String bizPath, String uploadType) &amp;#123; String url = \"\"; if(Constants.UPLOAD_TYPE_MINIO.equals(uploadType))&amp;#123; url = MinioUtil.upload(file,bizPath); &amp;#125;else&amp;#123; url = OssBootUtil.upload(file,bizPath); &amp;#125; return url; &amp;#125; @Override public String upload(MultipartFile file, String bizPath, String uploadType, String customBucket) &amp;#123; String url = \"\"; if(Constants.UPLOAD_TYPE_MINIO.equals(uploadType))&amp;#123; url = MinioUtil.upload(file,bizPath,customBucket); &amp;#125;else&amp;#123; url = OssBootUtil.upload(file,bizPath,customBucket); &amp;#125; return url; &amp;#125; @Override public void delImg(String delType, String delImgName) &amp;#123; try &amp;#123; if (Constants.UPLOAD_TYPE_MINIO.equals(delType))&amp;#123; MinioUtil.removeObject(miniBucketName, delImgName); &amp;#125;else &amp;#123; OssBootUtil.delete(delImgName); &amp;#125; &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件删除失败\" + e.getMessage()); &amp;#125; &amp;#125; &amp;#125; /** * 底层共通业务API，提供其他独立模块调用 * @Author: hfx * @Version:V1.0 */ public interface ISysBaseAPI &amp;#123; /** * 文件上传 * @param file 文件 * @param bizPath 自定义路径 * @param uploadType 上传方式 * @return */ public String upload(MultipartFile file, String bizPath, String uploadType); /** * 文件上传 自定义桶 * @param file * @param bizPath * @param uploadType * @param customBucket * @return */ public String upload(MultipartFile file, String bizPath, String uploadType, String customBucket); /** * 文件删除 * @param delType * @param delImgName * @return */ public void delImg(String delType, String delImgName); &amp;#125; 六、删除图片请求类（body） 可以根据自己业务需求及前端传参方式，确定是否需要。 /** * 删除图片请求类 */ @Data public class DeleteQO &amp;#123; /** * 需要删除的图片 */ private List&lt;Object> preDelImg; /** * 删除的图片目录 */ private String relativePath; /** * 需要保存的图片 */ // private List&lt;String>preSaveImg; &amp;#125; 七：**.yml中的配置文件可参考如下：upload: # 本地：local\\Minio：minio\\阿里云：alioss uploadType: minio path : #文件上传根目录 设置 upload: C://img #阿里云oss存储配置 oss: # OSS endpoint 创建桶时根据区域选择的endpoint endpoint: oss-cn-beijing.aliyuncs.com accessKey: secretKey: # 阿里云桶名 bucketName: # 服务器设置的OSS访问域名 默认endpoint staticDomain: # minio文件上传 minio: # minio访问路径ip/域名(测试ip，正式环境请修改) minio_url: http:// # 账号 minio_name: # 密码 minio_pass: # minio桶名称 bucketName: 注意：以上代码个人为了做到以后的需求迭代，有点方法没有用到，请根据自己需求进行删减。以上代码如发现bug及不足，请留言……"}],"posts":[{"title":"Mysql调优详解","slug":"Mysql调优详解","date":"2020-09-01T13:18:08.000Z","updated":"2020-09-12T02:28:31.310Z","comments":true,"path":"2020/09/01/Mysql调优详解/","link":"","permalink":"http://yoursite.com/2020/09/01/Mysql%E8%B0%83%E4%BC%98%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"Mysql调优详解 查询返回多条数据多列合并 一、GROUP_CONCAT([DISTINCT]要连接的字段 [Order BY 排序字段 ASC/DESC] [Separator ‘分隔符’])—–à默认使用逗号分隔，支持多个列拼接在一行展示。 语法： GROUP_CONCAT(str1,str2,..., Order BY ASC/DESC, SEPARATOR ',') 二、CONCAT_WS（separator,str1,str2,……） 将多个列使用指定字符串进行拼接成一个字符串返回。与CONCAT（str1,str2,str3,……）的区别，当CONCAT函数中返回的任意一个字段的值为NULL时，则整个返回结果就为NULL，而当CONCAT_WS函数中任意一个字段的值为NULL时，则会自动忽略此列的值进行拼接；当CONCAT函数中返回的任意一个字段的值为’ ’时，则返回结果会将空白项拼接在字符串中返回。 语法： CONCAT_WS(separator,str1,str2,……) SQL语句优化策略： .避免全表扫描对查询进行优化，应尽量避免全表扫描，首先应考虑在where 及order by 涉及的列上建立索引。 当有一批处理的插入或更新时，用批量插入或批量更新（Mybatis-plus也支持批量插入/更新），绝不会一条条记录的去更新! 查询语法中的字段任何地方都不要使用select _ from t_ ，用具体的字段列表代替“”，不要返回用不到的任何字段。 联表查询优化：多张数据表查询数据，使用inner join，left/right join来代替子查询，可以提高查询的效率。join : （阿里规约不要超过联接5个表查询）&gt; inner join其返回的结果为被连接的两个数据表的乘积，因此当有WHERE, ON或USING条件的时候一般不建议使用，因为当数据表项目太多的时候，会非常慢。一般使用LEFT [OUTER] JOIN或者RIGHT [OUTER] JOIN ORDER BY 排序注意字段类型（正常情况下排序字段为数字类型）数字 类型：order by 字段 排序方式字符串类型：order by cast(字段 as char)字符串 类型的数字：1：order by (字段+0) 排序方式 2： order by cast(字段 as unsigned)枚举类型：默认是按照枚举的下标排序的，如果想按照字符串排序跟字符串排序是一样的使用按照指定的数据方式排序：order by field(字段,’排序值’,’排序值’,’’) 解释：排序值可以一只加，第一个是字段就好，排序值可以是空，但是排序值相同时，按照找的第一个json类型：order by cast(JSON_EXTRACT(json字段, ‘$.json字段属性名’) as 序号类型) 注：序号类型unsigned(数字) char(字符串) json类型排序在5.7中才有效例如:有字段parame 的json字段 json里面有id,sex,hobbyorder by cast(JSON_EXTRACT(parame ,’$.id’) as unsigned) 使用表的别名(Alias)：当在SQL语句中连接多个表时,请使用表的别名并把别名前缀于每个Column上.这样一来,就可以减少解析的时间并减少那些由Column歧义引起的语法错误。别名是大型数据库的应用技巧，就是表名、列名在查询中以一个字母为别名，查询速度要比建连接表快1.5倍。 .避免判断null 值应尽量避免在where 子句中对字段进行null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num 上设置默认值0，确保表中num 列没有null 值，然后这样查询：select id from t where num=0 .避免不等值判断应尽量避免在where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。 尽量使用“&gt;=”，不要使用“&gt;”。 .避免使用or 逻辑应尽量避免在where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20可以这样查询：select id from t where num=10union allselect id from t where num=20&gt; 用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关,如果查询需要用到联合索引，用UNION all执行的效率更高.多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。 .慎用in 和not in 逻辑in 和not in 也要慎用，否则会导致全表扫描，如：select id from t1 where num in(select id from t2 where id &gt; 10)此时外层查询会全表扫描，不使用索引。可以修改为：select id from t1,(select id from t1 where id &gt; 10)t2 where t1.id = t2.id此时索引被使用，可以明显提升查询效率。 如果使用in：在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数。 between 代替 in在连续数值的查询中，能使用between的情况下，尽量使用between，而不使用in。in和not in都会导致全表查询。 .注意模糊查询like&gt; 在使用like进行数据表的查询时，能用单%的情况下，不建议使用双%，双%查询会导致mysql引擎放弃使用索引而进行全表扫描查询。 下面的查询也将导致全表扫描：select id from t where name like ‘%abc%’模糊查询如果是必要条件时，可以使用select id from t where name like ‘abc%’来实现模糊查询，此时索引将被使用。如果头匹配是必要逻辑，建议使用：1、全文搜索引擎（Elastic search、Lucene、Solr 等）2、使用mysql5.5以后的虚拟字段，实现统一前缀，来达到使用索引的目的。 避免查询条件中字段计算应尽量避免在where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为:select id from t where num=100*2 避免查询条件中对字段进行函数操作应尽量避免在where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’–name 以abc 开头的id应改为:select id from t where name like ‘abc%’ WHERE 子句“=”左边注意点不要在where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 组合索引使用在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致（最左匹配原则）。 不要定义无异议的查询不要写一些没有意义的查询，如需要生成一个空表结构：select col1,col2 into #t from t where 1=0这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：create table #t(…) exists1、很多时候用exists 代替in 是一个好的选择：select num from a where num in(select num from b)用下面的语句替换：select num from a where exists(select 1 from b where num=a.num)2、使用exists代替select count(1)来判断是否存在记录，count函数只有在统计表中所有行数时使用 索引也可能失效并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL 查询可能不会去利用索引，如一表中有字段sex，male、female 几乎各一半，那么即使在sex 上建了索引也对查询效率起不了作用。 使用 “explain” 对SQL语句进行分析，从而使SQL语句使用到索引！ 表格字段类型选择 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先可变长度字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 尽量用union all 代替 union&gt; union 是对数据进行并集操作，不包括重复行，同时进行默认排序 union all 是对数据进行并集操作，包括重复行，不进行排序 union 和 union all 的差异主要是前者需要将两个（或者多个）接过集 合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟，所以当我们可以确认结果集或者不在乎重复结果集的时候，尽量使用union all 而不是 union。 索引无关优化不使用、尽量不使用union，union all 等关键字、尽量不使用or 关键字、尽量使用等值判断。表连接建议不超过5 个。如果超过5 个，则考虑表格的设计。*（互联网应用中）表连接方式使用外联优于内联。外连接有基础数据存在。如：A left join B,基础数据是A。A inner join B，没有基础数据的，先使用笛卡尔积完成全连接，在根据连接条件得到内连接结果集。大数据量级的表格做分页查询时，如果页码数量过大，则使用子查询配合完成分页逻辑**。Select * from table limit 1000000, 10Select * from table where id in (select pk from table limit100000, 10) 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。阿里规约一个表的索引数最好不要超过5个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。避免频繁创建和删除临时表，以减少系统表资源的消耗。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 29.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 30.尽量避免大事务操作，提高系统并发能力。 MySQL优化器可优化的SQL类型&gt; 重新定义表的关联顺序 将外连接转换成内连接使用等价变换规则优化count()、min()和max()将一个表达式转化为常数表达式使用等价变换规则子查询优化提前终止查询对in()条件进行优化 *选择最有效率的表名顺序(只在基于规则的优化器中有效)： *oracle 的解析器按照从右到左的顺序处理FROM子句中的表名，FROM子句中写在最后的表(基础表 driving table)将被最先处理，在FROM子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指那个被其他表所引用的表. *提高GROUP BY语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉.下面两个查询返回相同结果，但第二个明显就快了许多. *低效:SELECT JOB , AVG(SAL)FROM EMPGROUP BY JOBHAVING JOB =’PRESIDENT’OR JOB =’MANAGER’高效:SELECT JOB , AVG(SAL)FROM EMPWHERE JOB =’PRESIDENT’OR JOB =’MANAGER’GROUP BY JOB sql语句用大写，因为oracle/MySql 总是先解析sql语句，把小写的字母转换成大写的再执行。 查询缓冲并不自动处理空格，因此，在写SQL语句时，应尽量减少空格的使用，尤其是在SQL首和尾的空格(因为，查询缓冲并不自动截取首尾空格)。 避免死锁，在你的存储过程和触发器中访问同一个表时总是以相同的顺序;事务应经可能地缩短，在一个事务中应尽可能减少涉及到的数据量;永远不要在事务中等待用户输入。 避免使用临时表（tag：视图），除非却有需要，否则应尽量避免使用临时表，相反，可以使用表变量代替;大多数时候(99%)，表变量驻扎在内存中，因此速度比临时表更快，临时表驻扎在TempDb数据库中，因此临时表上的操作需要跨数据库通信，速度自然慢。 EXPLAIN SELECT 查询用来跟踪查看效果使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等。 *选择表合适存储引擎： *（使用最多的是Innodb） myisam: 应用时以读和插入操作为主，只有少量的更新和删除，并且对事务的完整性，并发性要求不是很高的。*Innodb： *事务处理，以及并发条件下要求数据的一致性。除了插入和查询外，包括很多的更新和删除。（Innodb有效地降低删除和更新导致的锁定）。对于支持事务的InnoDB类型的表来说，影响速度的主要原因是AUTOCOMMIT默认设置是打开的，而且程序没有显式调用BEGIN 开始事务，导致每插入一条都自动提交，严重影响了速度。可以在执行sql前调用begin，多条sql形成一个事物（即使autocommit打开也可以），将大大提高性能。 索引创建规则：·表的主键、外键必须有索引；·经常与其他表进行连接的表，在连接字段上应该建立索引；·经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；·索引应该建在选择性高的字段上；·索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；（可用搜索引擎ES）· **复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替；**·正确选择复合索引中的主列字段，一般是选择性较好的字段；·复合索引的几个字段是否经常同时以 “AND” 方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；·如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；·如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；·如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；·频繁进行数据操作的表，不要建立太多的索引；·删除无用的索引，避免对执行计划造成负面影响；·表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。·尽量不要对数据库中某个含有大量重复的值的字段建立索引。·在适当的情形下使用GROUP BY而不是DISTINCT，在WHERE, GROUP BY和ORDER BY子句中使用有索引的列，保持索引简单,不在多个索引中包含同一个列，有时候MySQL会使用错误的索引,对于这种情况使用USE INDEX，检查使用SQL_MODE=STRICT的问题，对于记录数小于5的索引字段，在UNION的时候使用LIMIT不是是用OR。 优化表的数据类型,选择合适的数据类型：（建表时）原则：更小通常更好，简单就好，所有字段都得有默认值,尽量避免null。 **例如：数据库表设计时候更小的占磁盘空间尽可能使用更小的整数类型.(mediumint就比int更合适)比如时间字段：datetime和timestamp, datetime占用8个字节，而timestamp占用4个字节，只用了一半，而timestamp表示的范围是1970—2037适合做更新时间MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。**应该尽量把字段设置为NOT NULL，这样在将来执行查询的时候，数据库不用去比较NULL值。对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。 任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。 更多优化策略后期会持续更新此文章！","categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"Stream流相关操作","slug":"Stream流相关操作","date":"2020-08-20T13:00:08.000Z","updated":"2020-09-12T02:38:13.263Z","comments":true,"path":"2020/08/20/Stream流相关操作/","link":"","permalink":"http://yoursite.com/2020/08/20/Stream%E6%B5%81%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Stream流相关操作Stream流一、Stream的中间操作 distinct()：去重```javaUser.Stream().distinct() filter：过滤```javastudents.stream().filter(student -&gt; “清华大学”.equals(student.getSchool())).collect(Collectors.toList()); limit：limit操作也类似于SQL语句中的LIMIT关键字，不过相对功能较弱，limit返回包含前n个元素的流，当集合大小小于n时，则返回实际长度。```javastudents.stream().filter(student -&gt; “计算机”.equals(student.getMajor())).limit(2).collect(Collectors.toList()); .sorted() ：排序```java// 状态排序orderListDTOS.stream().sorted(Comparator.comparing(OrderListDTO::getOrderStatusStr) // 评价时间 为null靠前 .thenComparing(OrderListDTO::getEvaluateTime, Comparator.nullsFirst(String::compareTo).reversed()) // 下单时间 倒序 .thenComparing(OrderListDTO::getOrderTime, Comparator.nullsFirst(String::compareTo)).reversed()) // 赋值给新集合 进行保存 .collect(Collectors.toList()).forEach(order -&gt; &#123; OrderListDTO orderListDTO = new OrderListDTO(); BeanUtils.copyProperties(order, orderListDTO); orders.add(orderListDTO); &#125;); skip：是跳过前n个元素```javastudents.stream().filter(student -&gt; “计算机科学”.equals(student.getMajor())).skip(2) of：实现判断```javaString status = pouch.getStatus();if (Stream.of( &quot;Finalized&quot;, &quot;Ready&quot;, &quot;Checkout&quot;, &quot;Confirmed&quot;, &quot;Book&quot;, &quot;Started&quot;, &quot;Inital&quot;, &quot;Close&quot;) .anyMatch(status::equals)) &#123;// anyMatch：检测是否存在一个或多个满足指定的参数行为 // 逻辑代码块} 二、终端操作：2.1 查找： allMatch：allMatch用于检测是否全部都满足指定的参数行为，如果全部满足则返回true，如下：学生年龄是否大于等于18。```javaboolean isAdult = students.stream().allMatch(student -&gt; student.getAge() &gt;= 18); anyMatch：anyMatch则是检测是否存在一个或多个满足指定的参数行为，如果满足则返回true，如下：所有学生中是否有清华大学的学生。```javaboolean hasWhu = students.stream().anyMatch(student -&gt; “清华大学”.equals(student.getSchool())); noneMathch：noneMatch用于检测是否不存在满足指定行为的元素，如果不存在则返回true，如下：检测是否不存在专业为计算机科学的学生。```javaboolean noneCs = students.stream().noneMatch(student -&gt; “计算机科学”.equals(student.getMajor())); findFirst：用于返回满足条件的第一个元素```javastudents.stream().filter(student -&gt; “计算机科学”.equals(student.getMajor())).findFirst(); findAny：相对于findFirst的区别在于，findAny不一定返回第一个，而是返回任意一个```javastudents.stream().filter(student -&gt; “计算机”.equals(student.getMajor())).findAny(); &gt; 实际上对于顺序流式处理而言，findFirst和findAny返回的结果是一样的，至于为什么会这样设计，是因为在下一篇我们介绍的**并行流式处理**，当我们启用并行流式处理的时候，查找第一个元素往往会有很多限制，如果不是特别需求，在**并行流式处理中使用findAny的性能要比findFirst好**。 2.2 归约： 我们大部分都是通过collect(Collectors.toList())对数据封装返回，如我的目标不是返回一个新的集合，而是希望对经过参数化操作后的集合进行进一步的运算，那么我们可用对集合实施归约操作。java8的流式处理提供了reduce方法来达到这一目的。 前面我们通过mapToInt将Stream&lt;Student&gt;映射成为IntStream，并通过IntStream的sum方法求得所有学生的年龄之和，实际上我们通过归约操作，也可以达到这一目的，实现如下： ​```java// 前面例子中的方法int totalAge = students.stream() .filter(student -&gt; “计算机科学”.equals(student.getMajor())) .mapToInt(Student::getAge).sum();// 归约操作int totalAge = students.stream() .filter(student -&gt; “计算机科学”.equals(student.getMajor())) .map(Student::getAge) .reduce(0, (a, b) -&gt; a + b); // 进一步简化int totalAge2 = students.stream() .filter(student -&gt; “计算机科学”.equals(student.getMajor())) .map(Student::getAge) .reduce(0, Integer::sum); // 采用无初始值的重载版本，需要注意返回OptionalOptional totalAge = students.stream() .filter(student -&gt; “计算机科学”.equals(student.getMajor())) .map(Student::getAge) .reduce(Integer::sum); // 去掉初始值 **2.3 收集：** 前面利用**`collect(Collectors.toList())`是一个简单的收集操作，是对处理结果的封装**，对应的还有**`toSet`、`toMap`**，以满足我们对于结果组织的需求。这些方法均来自于`java.util.stream.Collectors`，我们可以称之为收集器。 **2.3.1 规约：** &gt; **收集器也提供了相应的归约操作**，但是与reduce在内部实现上是有区别的**，收集器更加适用于可变容器上的归约操作**，这些收集器广义上均基于**`Collectors.reducing()`**实现。 (1). 求学生总数：**.count()、Collectors.counting()** ```java long count = students.stream().collect(Collectors.counting()); // 进一步简化 long count = students.stream().count();(2). 求最大值和最小值：Collectors.maxBy、Collectors.minBy // 求最大年龄 Optional&lt;Student> olderStudent = students.stream().collect(Collectors.maxBy((s1, s2) -> s1.getAge() - s2.getAge())); // 进一步简化 Optional&lt;Student> olderStudent2 = students.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge))); // 求最小年龄 Optional&lt;Student> olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge))); (3). 求总和：Collectors.summingInt int totalAge4 = students.stream().collect(Collectors.summingInt(Student::getAge)); // 对应的还有summingLong、summingDouble。 求平均值：**Collectors.averagingInt**double avgAge = students.stream().collect(Collectors.averagingInt(Student::getAge)); // 对应的还有averagingLong、averagingDouble。 一次性得到元素个数、总和、均值、最大值、最小值:IntSummaryStatistics statistics = students.stream().collect(Collectors.summarizingInt(Student::getAge)); // 输出： IntSummaryStatistics&amp;#123;count=10, sum=220, min=20, average=22.000000, max=24&amp;#125; 对应的还有summarizingLong、summarizingDouble… (4). 字符串拼接 : Collectors.joining(“”) String names = students.stream().map(Student::getName).collect(Collectors.joining()); // 输出：孔明伯约玄德云长翼德元直奉孝仲谋鲁肃丁奉 String names = students.stream().map(Student::getName).collect(Collectors.joining(\", \")); // 输出：孔明, 伯约, 玄德, 云长, 翼德, 元直, 奉孝, 仲谋, 鲁肃, 丁奉 2.3.2 分组： 在数据库操作中，我们可以通过GROUP BY关键字对查询到的数据进行分组，java8的流式处理也为我们提供了这样的功能Collectors.groupingBy来操作集合： students.stream().collect( Collectors.groupingBy(Student::getSchool, // 一级分组，按学校 Collectors.groupingBy(Student::getMajor))); // 二级分组，按专业 实际上在groupingBy的第二个参数不是只能传递groupingBy，还可以传递任意Collector类型，比如我们可以传递一个Collector.counting，用以统计每个组的个数： Map&lt;String, Long> groups = students.stream().collect(Collectors.groupingBy(Student::getSchool, Collectors.counting())); 如果我们不添加第二个参数，则编译器会默认帮我们添加一个Collectors.toList()。 2.3.3 分区： 分区可以看做是分组的一种特殊情况，在分区中key只有两种情况：true或false，目的是将待分区集合按照条件一分为二，处理利用collectors.partitioningBy()方法实现分区，该方法接收一个谓词，例如我们希望将学生分为武大学生和非武大学生，那么可以实现如下： Map&lt;Boolean, List&lt;Student>> partition = students.stream().collect(Collectors.partitioningBy(student -> \"武汉大学\".equals(student.getSchool()))); 例如：比如将数组分为奇数和偶数。 三、parallelStream（并行流，相比于Stream更快但是涉及到线程安全）list.parallelStream().map(e -&gt; e + 3).collect(Collectors.toList()); parallelStream在处理大的数据量的集合时使用，但是线程不安全，可以先map，再.collect(Collectors.toList()，.collect(Collectors.toList()可以封装一个List集合返回，还可以保证线程安全。 ——-错误记录：——- 1、Collectors.toMap value为null报错 Map&lt;String, Integer> map3 = new HashMap&lt;>(0); map3 = list3.stream().collect(Collectors.toMap( list3 -> Optional.ofNullable(list3).map(SpGoodsIdAndCount::getGoodsId).orElse(\"\") , list3 -> Optional.ofNullable(list3).map(SpGoodsIdAndCount::getCount).orElse(0) , (key1, key2) -> key2)); 解析：Collectors.toMap(）：list集合转换为map，通过Optional判断当key和value为null时赋予默认值。(key1, key2) -&gt; key2)：当key重复时，选择key2作为新的key值。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"java中使用@Value获取值为null问题解决","slug":"java中使用@Value获取值为null问题解决","date":"2020-08-19T15:08:10.000Z","updated":"2020-09-12T02:45:35.912Z","comments":true,"path":"2020/08/19/java中使用@Value获取值为null问题解决/","link":"","permalink":"http://yoursite.com/2020/08/19/java%E4%B8%AD%E4%BD%BF%E7%94%A8@Value%E8%8E%B7%E5%8F%96%E5%80%BC%E4%B8%BAnull%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"","text":"java中使用@Value获取值为null问题解决：问题重现：读取配置文件(**.yml)中的值，获取为null // 读取配置文件(**.yml)中的值 @Value(value = \"$&amp;#123;upload.minio.minio_url&amp;#125;\") private static String minioUrl; 问题解析： java中static/final修饰的变量，通过@Value是获取不到值的。 问题解决方案： 方案一：在变量的*seter方法上使用@Value * 1.静态变量的setter 方法需要去掉 static 修饰词， 2.并需要使用public修饰， 3.最后需要注意要*在类上加上@Component *，才可以成功注入。 @Value(value = \"$&amp;#123;upload.minio.minio_url&amp;#125;\") public static void setMinioUrl(String minioUrl) &amp;#123; MinioUtil.minioUrl = minioUrl; &amp;#125; 方案二：通过中间变量赋值：*在类上加上@Component * private static String minioUrl; @Value(value = \"$&amp;#123;upload.minio.minio_url&amp;#125;\") private String minioUrl2; @PostConstruct public void init() &amp;#123; minioUrl = minioUrl2; &amp;#125; 总结： 解决方案有两种，都是间接的通过非static的变量获取到值，从而拿到.yml中的值；但是，两种方法中都需要在类上加上@Component。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"request.getParameter(&quot;**&quot;)获取不到值","slug":"request.getParameter(____)获取不到值","date":"2020-08-08T13:18:08.000Z","updated":"2020-09-12T02:37:37.393Z","comments":true,"path":"2020/08/08/request.getParameter(____)获取不到值/","link":"","permalink":"http://yoursite.com/2020/08/08/request.getParameter(____)%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%80%BC/","excerpt":"","text":"request.getParameter(&quot;**&quot;)获取不到值：需求场景： 上传图片功能中，为了更好的维护图片，要求前端在请求中传递一个路径参数。 问题解析： 归根结底就是HTML中的form表单有一个关键属性enctype＝application/x-www-form-urlencoded导致的。 request.getParameter(“…”)在enctype＝application/x-www-form-urlencoded配置下可以获取到值。由于需求场景是上传文件，所以前端请求过来的是：multipart/form-data，导致request.getParameter(“…”)获取不到值。 解决方案：通过request.getInputStream()、request.getReader(）替换request.getParameter() 一、request.getInputStream() 二、request.getReader(“前端放在请求头中参数名称”) 总结：我是采用第二种直接获取请求头中的参数，第一种未测试。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"feign调用异常：Method has too many Body parameters","slug":"feign调用异常：java.lang.IllegalStateException_ Method has too many Body parameters","date":"2020-07-22T12:08:18.000Z","updated":"2020-09-12T02:24:50.160Z","comments":true,"path":"2020/07/22/feign调用异常：java.lang.IllegalStateException_ Method has too many Body parameters/","link":"","permalink":"http://yoursite.com/2020/07/22/feign%E8%B0%83%E7%94%A8%E5%BC%82%E5%B8%B8%EF%BC%9Ajava.lang.IllegalStateException_%20Method%20has%20too%20many%20Body%20parameters/","excerpt":"","text":"java.lang.IllegalStateException: Method has too many Body parametersfeign调用异常：Method has too many Body parameters 解决方法：所有参数必须加上注解 @RequestMapping(value = \"/spCommodity/commodityPage\", method = RequestMethod.POST) R goodsList(Page page, @RequestBody CommodityListQO commodityListQO);// 会报错 get请求：参数要加上注解@RequestParam post请求：只能有一个@RequestBody，Page属于一个对象，可删除，其余的参数需要加上@RequestParam feign调用的接口处可修改： @PostMapping(\"/commodityPage\") public R goodsList(@RequestBody CommodityListQO commodityListQO)&amp;#123; Page&lt;SpServiceCommodity> page = new Page&lt;>(); // 页数 page.setCurrent(commodityListQO.getCurrent()); // 每页显示条数 page.setSize(commodityListQO.getSize());","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"minio搭建上传图片(文件)使用教程（在docker中创建）","slug":"minio搭建上传图片(文件)使用教程（在docker中创建）","date":"2020-07-20T13:18:08.000Z","updated":"2020-09-12T02:27:54.101Z","comments":true,"path":"2020/07/20/minio搭建上传图片(文件)使用教程（在docker中创建）/","link":"","permalink":"http://yoursite.com/2020/07/20/minio%E6%90%AD%E5%BB%BA%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87(%E6%96%87%E4%BB%B6)%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%EF%BC%88%E5%9C%A8docker%E4%B8%AD%E5%88%9B%E5%BB%BA%EF%BC%89/","excerpt":"","text":"minio搭建上传图片(文件)使用教程（在docker中创建）： 使用服务器CentOS 7.0，版本：3.10.0-1127.10.1.el7.x86_64 一、查看服务器版本（使用minio版本好像需要在3.0.xx以上，其他版本请自行测试）：uname -r 二、安装docker容器。（其他安装方法请百度）2.1：安装yum源 yum install -y epel-release 2.2：通过yum安装docker容器 yum install docker-io 2.3：查看docker版本, 确定是否安装成功 docker version 三、创建文件在服务器上的存储路径：(可以自行命名创建) chmod 777 /home/data/minio/data (设置文件夹最高权限：777读写执行) mkdir -p /home/data/minio/data mkdir -p /home/data/minio/config chmod 777 /home/data/minio/data 四、在docker中创建minio MINIO_ACCESS_KEY，MINIO_SECRET_KEY：请自行设置（便于记忆） docker run -p 9000:9000 -e MINIO_ACCESS_KEY=MINIO_TEST_ADMIN -e MINIO_SECRET_KEY=123456 -v /data:/data minio/minio server /data _出现如下信息则证明成功，_可通过：http://服务器ip:9000进行访问。 You are running an older version of MinIO released 1 day ago Update: docker pull minio/minio:RELEASE.2020-08-27T05-16-20Z Endpoint: http://***.**.**.**:9000 http://127.0.0.1:9000 Browser Access: http://***.**.**.**:9000 http://127.0.0.1:9000 Object API (Amazon S3 compatible): Go: https://docs.min.io/docs/golang-client-quickstart-guide Java: https://docs.min.io/docs/java-client-quickstart-guide Python: https://docs.min.io/docs/python-client-quickstart-guide JavaScript: https://docs.min.io/docs/javascript-client-quickstart-guide .NET: https://docs.min.io/docs/dotnet-client-quickstart-guide 查看启动结果： docker ps -a","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"java上传图片(文件)到minio/oss/local本地","slug":"java上传图片(文件)到minio_oss_local本地","date":"2020-07-20T13:18:08.000Z","updated":"2020-09-12T02:26:08.214Z","comments":true,"path":"2020/07/20/java上传图片(文件)到minio_oss_local本地/","link":"","permalink":"http://yoursite.com/2020/07/20/java%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87(%E6%96%87%E4%BB%B6)%E5%88%B0minio_oss_local%E6%9C%AC%E5%9C%B0/","excerpt":"","text":"java上传图片(文件)到minio/oss/local本地：代码文件已放在了Github：Github地址 以下代码较多，请根据自己需要，选取相应位置代码使用！minio、oss相关maven引入，我并没有贴出，请自行引入(只针对不熟悉minio和oss)。 一、Controller类代码：简介： 接口可以上传图片到minio、oss、local本地（一般windows服务使用）。1、minio在CentOS 7.0 中的搭建使用，请访问：minio搭建使用。2、alioss 存储的相关配置，请访问官网：阿里云OSS 具体代码如下： 请根据自己业务需求进行修改 /** * 文件上传 * @Author hfx */ @Slf4j @RestController @RequestMapping(\"/uploadCommon\") public class CommonController &amp;#123; @Autowired(required = false) private ISysBaseAPI sysBaseAPI; @Value(value = \"$&amp;#123;upload.path.upload&amp;#125;\") private String uploadpath; /** * 本地：local minio：minio 阿里：alioss */ @Value(value=\"$&amp;#123;upload.uploadType&amp;#125;\") private String uploadType; /** * 文件上传统一方法 * @param request * @param response * @return */ @PostMapping(value = \"/upload\") public R&lt;?> upload(HttpServletRequest request, HttpServletResponse response) throws IOException &amp;#123; log.info(\"上传路径uploadpath:&amp;#123;&amp;#125;\", uploadpath); log.info(\"上传类型uploadType:&amp;#123;&amp;#125;\", uploadType); R result = new R(); String savePath = \"\"; // String bizPath = request.getParameter(\"path\"); String bizPath = request.getHeader(\"path\"); log.info(\"bizPath:&amp;#123;&amp;#125;\", bizPath); MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request; MultipartFile file = multipartRequest.getFile(\"file\");// 获取上传文件对象 if(StrUtil.isEmpty(bizPath))&amp;#123; if(Constants.UPLOAD_TYPE_OSS.equals(uploadType))&amp;#123; //未指定目录，则用阿里云默认目录 upload ,使用阿里云文件上传时，必须添加目录！ bizPath = \"upload\"; &amp;#125;else&amp;#123; bizPath = \"didiDefaultFile\"; &amp;#125; &amp;#125; log.info(\"文件目录为path:&amp;#123;&amp;#125;\", bizPath); if(Constants.UPLOAD_TYPE_LOCAL.equals(uploadType))&amp;#123; //针对jeditor编辑器如何使 lcaol模式，采用 base64格式存储 String jeditor = request.getParameter(\"jeditor\"); if(StrUtil.isNotEmpty(jeditor))&amp;#123; result.setMsg(Constants.UPLOAD_TYPE_LOCAL); result.setData(Constants.UPLOAD_TYPE_LOCAL); result.setCode(0); return result; &amp;#125;else&amp;#123; savePath = this.uploadLocal(file,bizPath); &amp;#125; &amp;#125;else&amp;#123; savePath = sysBaseAPI.upload(file,bizPath,uploadType); &amp;#125; if(StrUtil.isNotEmpty(savePath))&amp;#123; result.setData(savePath); result.setCode(0); &amp;#125;else &amp;#123; result.setMsg(\"上传失败！\"); result.setCode(1); &amp;#125; return result; &amp;#125; /** * 本地文件上传 * @param mf 文件 * @param bizPath 自定义路径 * @return */ private String uploadLocal(MultipartFile mf, String bizPath)&amp;#123; try &amp;#123; String ctxPath = uploadpath; String fileName = null; File file = new File(ctxPath + File.separator + bizPath + File.separator ); if (!file.exists()) &amp;#123; file.mkdirs();// 创建文件根目录 &amp;#125; String orgName = mf.getOriginalFilename();// 获取文件名 orgName = CommonUtils.getFileName(orgName); if(orgName.indexOf(\".\")!=-1)&amp;#123; fileName = orgName.substring(0, orgName.lastIndexOf(\".\")) + \"_\" + System.currentTimeMillis() + orgName.substring(orgName.indexOf(\".\")); &amp;#125;else&amp;#123; fileName = orgName+ \"_\" + System.currentTimeMillis(); &amp;#125; String savePath = file.getPath() + File.separator + fileName; File savefile = new File(savePath); FileCopyUtils.copy(mf.getBytes(), savefile); String dbpath = null; if(StrUtil.isNotEmpty(bizPath))&amp;#123; dbpath = bizPath + File.separator + fileName; &amp;#125;else&amp;#123; dbpath = fileName; &amp;#125; if (dbpath.contains(\"\\\\\")) &amp;#123; dbpath = dbpath.replace(\"\\\\\", \"/\"); &amp;#125; return dbpath; &amp;#125; catch (IOException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; return \"\"; &amp;#125; /** * 删除图片 * @return */ @DeleteMapping(value = \"/deleteImg\") public R&lt;?> deleteImg(@RequestBody DeleteQO deleteQO) &amp;#123; // // 是否有需要删除的图片 // if (CollUtil.isEmpty(preDelImg)) // return R.ok(\"没有需要删除的图片！\"); // Collection&lt;String> preDelColl = new ArrayList&lt;>(preDelImg); // boolean delImg = preDelColl.removeAll(preSaveImg); List&lt;Object> preDelImg = deleteQO.getPreDelImg(); String relativePath = deleteQO.getRelativePath(); if (CollUtil.isNotEmpty(preDelImg)) &amp;#123; preDelImg.stream().forEach(img -> &amp;#123; log.info(\"删除的图片为：img:&amp;#123;&amp;#125;\", img); img = relativePath + \"/\" + StrUtil.subAfter((String)img, \"/\", true); sysBaseAPI.delImg(uploadType, (String) img); &amp;#125;); return R.ok(\"已删除图片:\" + preDelImg); &amp;#125; return R.ok(\"没有需要删除的新图片！\"); &amp;#125; &amp;#125; 二、CommonUtils类代码：（主要是处理文件名中的特殊符号）public class CommonUtils &amp;#123; /** * 判断文件名是否带盘符，重新处理 * @param fileName * @return */ public static String getFileName(String fileName)&amp;#123; //判断是否带有盘符信息 // Check for Unix-style path int unixSep = fileName.lastIndexOf('/'); // Check for Windows-style path int winSep = fileName.lastIndexOf('\\\\'); // Cut off at latest possible point int pos = (winSep > unixSep ? winSep : unixSep); if (pos != -1) &amp;#123; // Any sort of path separator found... fileName = fileName.substring(pos + 1); &amp;#125; //替换上传文件名字的特殊字符 fileName = fileName.replace(\"=\",\"\").replace(\",\",\"\").replace(\"&amp;\",\"\"); return fileName; &amp;#125; &amp;#125; 三、MinioUtil工具类（Minio上传、删除相关方法）/** * minio文件上传工具类 */ @Slf4j @Component public class MinioUtil &amp;#123; private static String minioUrl; private static String minioName; private static String minioPass; private static String bucketName; @Value(value = \"$&amp;#123;upload.minio.minio_url&amp;#125;\") public void setMinioUrl(String minioUrl) &amp;#123; MinioUtil.minioUrl = minioUrl; &amp;#125; @Value(value = \"$&amp;#123;upload.minio.minio_name&amp;#125;\") public void setMinioName(String minioName) &amp;#123; MinioUtil.minioName = minioName; &amp;#125; @Value(value = \"$&amp;#123;upload.minio.minio_pass&amp;#125;\") public void setMinioPass(String minioPass) &amp;#123; MinioUtil.minioPass = minioPass; &amp;#125; @Value(value = \"$&amp;#123;upload.minio.bucketName&amp;#125;\") public void setBucketName(String bucketName) &amp;#123; MinioUtil.bucketName = bucketName; &amp;#125; public static String getMinioUrl() &amp;#123; return minioUrl; &amp;#125; public static String getBucketName() &amp;#123; return bucketName; &amp;#125; private static MinioClient minioClient = null; /** * 上传文件 * @param file * @return */ public static String upload(MultipartFile file, String bizPath, String customBucket) &amp;#123; log.info(\"minio相关配置：minio_url:&amp;#123;&amp;#125;, minio_name:&amp;#123;&amp;#125;, minio_pass:&amp;#123;&amp;#125;, bucketName:&amp;#123;&amp;#125;\", minioUrl, minioName, minioPass, bucketName); String file_url = \"\"; String newBucket = bucketName; if(StrUtil.isNotEmpty(customBucket))&amp;#123; newBucket = customBucket; &amp;#125; try &amp;#123; initMinio(minioUrl, minioName,minioPass); // 检查存储桶是否已经存在 if(minioClient.bucketExists(newBucket)) &amp;#123; log.info(\"Bucket already exists.\"); &amp;#125; else &amp;#123; // 创建一个名为ota的存储桶 minioClient.makeBucket(newBucket); log.info(\"create a new bucket.\"); &amp;#125; InputStream stream = file.getInputStream(); // 获取文件名 String orgName = file.getOriginalFilename(); orgName = CommonUtils.getFileName(orgName); String objectName = bizPath+\"/\"+orgName.substring(0, orgName.lastIndexOf(\".\")) + \"_\" + System.currentTimeMillis() + orgName.substring(orgName.indexOf(\".\")); // 使用putObject上传一个本地文件到存储桶中。 minioClient.putObject(newBucket,objectName, stream, (long) stream.available(), null, null, \"application/octet-stream\"); stream.close(); file_url = minioUrl+newBucket+\"/\"+objectName; &amp;#125;catch (IOException e)&amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InvalidKeyException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (NoSuchAlgorithmException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (NoResponseException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (XmlPullParserException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InvalidArgumentException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (RegionConflictException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InvalidBucketNameException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (ErrorResponseException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InternalException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InsufficientDataException e) &amp;#123; log.error(e.getMessage(), e); &amp;#125; catch (InvalidResponseException e) &amp;#123; e.printStackTrace(); &amp;#125; return file_url; &amp;#125; /** * 文件上传 * @param file * @param bizPath * @return */ public static String upload(MultipartFile file, String bizPath) &amp;#123; return upload(file,bizPath,null); &amp;#125; /** * 获取文件流 * @param bucketName * @param objectName * @return */ public static InputStream getMinioFile(String bucketName,String objectName)&amp;#123; InputStream inputStream = null; try &amp;#123; initMinio(minioUrl, minioName, minioPass); inputStream = minioClient.getObject(bucketName, objectName); &amp;#125; catch (Exception e) &amp;#123; log.info(\"文件获取失败\" + e.getMessage()); &amp;#125; return inputStream; &amp;#125; /** * 删除文件 * @param bucketName * @param objectName * @throws Exception */ public static void removeObject(String bucketName, String objectName) &amp;#123; try &amp;#123; initMinio(minioUrl, minioName,minioPass); minioClient.removeObject(bucketName, objectName); &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件删除失败\" + e.getMessage()); &amp;#125; &amp;#125; /** * 获取文件外链 * @param bucketName * @param objectName * @param expires * @return */ public static String getObjectURL(String bucketName, String objectName, Integer expires) &amp;#123; initMinio(minioUrl, minioName,minioPass); try&amp;#123; String url = minioClient.presignedGetObject(bucketName, objectName, expires); return URLDecoder.decode(url,\"UTF-8\"); &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件路径获取失败\" + e.getMessage()); &amp;#125; return null; &amp;#125; /** * 初始化客户端 * @param minioUrl * @param minioName * @param minioPass * @return */ private static MinioClient initMinio(String minioUrl, String minioName,String minioPass) &amp;#123; if (minioClient == null) &amp;#123; try &amp;#123; minioClient = new MinioClient(minioUrl, minioName,minioPass); &amp;#125; catch (InvalidEndpointException e) &amp;#123; e.printStackTrace(); &amp;#125; catch (InvalidPortException e) &amp;#123; e.printStackTrace(); &amp;#125; &amp;#125; return minioClient; &amp;#125; /** * 上传文件到minio * @param stream * @param relativePath * @return */ public static String upload(InputStream stream,String relativePath) throws IOException, InvalidKeyException, NoSuchAlgorithmException, InsufficientDataException, InternalException, NoResponseException, InvalidBucketNameException, XmlPullParserException, ErrorResponseException, RegionConflictException, InvalidArgumentException, InvalidResponseException &amp;#123; initMinio(minioUrl, minioName,minioPass); if(minioClient.bucketExists(bucketName)) &amp;#123; log.info(\"Bucket already exists.\"); &amp;#125; else &amp;#123; // 创建一个名为ota的存储桶 minioClient.makeBucket(bucketName); log.info(\"create a new bucket.\"); &amp;#125; minioClient.putObject(bucketName,relativePath, stream, (long) stream.available(), null, null, \"application/octet-stream\"); stream.close(); return minioUrl+bucketName+\"/\"+relativePath; &amp;#125; &amp;#125; 四、OssBootUtil工具类（OSS上传、删除相关方法）/** * 阿里云 oss 上传工具类 */ @Slf4j @Component public class OssBootUtil&amp;#123; private static String endPoint; private static String accessKeyId; private static String accessKeySecret; private static String bucketName; private static String staticDomain; @Value(value = \"$&amp;#123;upload.oss.endpoint&amp;#125;\") public void setEndPoint(String endPoint) &amp;#123; OssBootUtil.endPoint = endPoint; &amp;#125; @Value(value = \"$&amp;#123;upload.oss.accessKey&amp;#125;\") public void setAccessKeyId(String accessKeyId) &amp;#123; OssBootUtil.accessKeyId = accessKeyId; &amp;#125; @Value(value = \"$&amp;#123;upload.oss.secretKey&amp;#125;\") public void setAccessKeySecret(String accessKeySecret) &amp;#123; OssBootUtil.accessKeySecret = accessKeySecret; &amp;#125; @Value(value = \"$&amp;#123;upload.oss.bucketName&amp;#125;\") public void setBucketName(String bucketName) &amp;#123; OssBootUtil.bucketName = bucketName; &amp;#125; // @Value(value = \"$&amp;#123;upload.oss.staticDomain&amp;#125;\") public void setStaticDomain(String staticDomain) &amp;#123; OssBootUtil.staticDomain = staticDomain; &amp;#125; /** * oss 工具客户端 */ private static OSSClient ossClient = null; /** * 上传文件至阿里云 OSS * 文件上传成功,返回文件完整访问路径 * 文件上传失败,返回 null * * @param file 待上传文件 * @param fileDir 文件保存目录 * @return oss 中的相对文件路径 */ public static String upload(MultipartFile file, String fileDir, String customBucket) &amp;#123; log.info(\"oss配置信息：enPoint:&amp;#123;&amp;#125;,accessKeyId:&amp;#123;&amp;#125;,accessKeySecret:&amp;#123;&amp;#125;,bucketName:&amp;#123;&amp;#125;,staticDomain:&amp;#123;&amp;#125;\", endPoint, accessKeyId, accessKeySecret, bucketName, staticDomain); String FILE_URL = null; initOSS(endPoint, accessKeyId, accessKeySecret); StringBuilder fileUrl = new StringBuilder(); String newBucket = bucketName; if(StrUtil.isNotEmpty(customBucket))&amp;#123; newBucket = customBucket; &amp;#125; try &amp;#123; //判断桶是否存在,不存在则创建桶 if(!ossClient.doesBucketExist(newBucket))&amp;#123; ossClient.createBucket(newBucket); &amp;#125; // 获取文件名 String orgName = file.getOriginalFilename(); orgName = CommonUtils.getFileName(orgName); String fileName = orgName.substring(0, orgName.lastIndexOf(\".\")) + \"_\" + System.currentTimeMillis() + orgName.substring(orgName.indexOf(\".\")); if (!fileDir.endsWith(\"/\")) &amp;#123; fileDir = fileDir.concat(\"/\"); &amp;#125; fileUrl = fileUrl.append(fileDir + fileName); if (StrUtil.isNotEmpty(staticDomain) &amp;&amp; staticDomain.toLowerCase().startsWith(\"http\")) &amp;#123; FILE_URL = staticDomain + \"/\" + fileUrl; &amp;#125; else &amp;#123; FILE_URL = \"https://\" + newBucket + \".\" + endPoint + \"/\" + fileUrl; &amp;#125; PutObjectResult result = ossClient.putObject(newBucket, fileUrl.toString(), file.getInputStream()); // 设置权限(公开读) // ossClient.setBucketAcl(newBucket, CannedAccessControlList.PublicRead); if (result != null) &amp;#123; log.info(\"------OSS文件上传成功------\" + fileUrl); &amp;#125; &amp;#125; catch (IOException e) &amp;#123; e.printStackTrace(); return null; &amp;#125; return FILE_URL; &amp;#125; /** * 文件上传 * @param file * @param fileDir * @return */ public static String upload(MultipartFile file, String fileDir) &amp;#123; return upload(file, fileDir,null); &amp;#125; /** * 上传文件至阿里云 OSS * 文件上传成功,返回文件完整访问路径 * 文件上传失败,返回 null * * @param file 待上传文件 * @param fileDir 文件保存目录 * @return oss 中的相对文件路径 */ public static String upload(FileItemStream file, String fileDir) &amp;#123; String FILE_URL = null; initOSS(endPoint, accessKeyId, accessKeySecret); StringBuilder fileUrl = new StringBuilder(); try &amp;#123; String suffix = file.getName().substring(file.getName().lastIndexOf('.')); String fileName = UUID.randomUUID().toString().replace(\"-\", \"\") + suffix; if (!fileDir.endsWith(\"/\")) &amp;#123; fileDir = fileDir.concat(\"/\"); &amp;#125; fileUrl = fileUrl.append(fileDir + fileName); if (StrUtil.isNotEmpty(staticDomain) &amp;&amp; staticDomain.toLowerCase().startsWith(\"http\")) &amp;#123; FILE_URL = staticDomain + \"/\" + fileUrl; &amp;#125; else &amp;#123; FILE_URL = \"https://\" + bucketName + \".\" + endPoint + \"/\" + fileUrl; &amp;#125; PutObjectResult result = ossClient.putObject(bucketName, fileUrl.toString(), file.openStream()); // 设置权限(公开读) ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead); if (result != null) &amp;#123; log.info(\"------OSS文件上传成功------\" + fileUrl); &amp;#125; &amp;#125; catch (IOException e) &amp;#123; e.printStackTrace(); return null; &amp;#125; return FILE_URL; &amp;#125; /** * 删除文件 * @param url */ public static void deleteUrl(String url) &amp;#123; deleteUrl(url,null); &amp;#125; /** * 删除文件 * @param url */ public static void deleteUrl(String url,String bucket) &amp;#123; String newBucket = bucketName; if(StrUtil.isNotEmpty(bucket))&amp;#123; newBucket = bucket; &amp;#125; String bucketUrl = \"\"; if (StrUtil.isNotEmpty(staticDomain) &amp;&amp; staticDomain.toLowerCase().startsWith(\"http\")) &amp;#123; bucketUrl = staticDomain + \"/\" ; &amp;#125; else &amp;#123; bucketUrl = \"https://\" + newBucket + \".\" + endPoint + \"/\"; &amp;#125; url = url.replace(bucketUrl,\"\"); ossClient.deleteObject(newBucket, url); &amp;#125; /** * 删除文件 * @param fileName */ public static void delete(String fileName) &amp;#123; ossClient.deleteObject(bucketName, fileName); &amp;#125; /** * 获取文件流 * @param objectName * @param bucket * @return */ public static InputStream getOssFile(String objectName,String bucket)&amp;#123; InputStream inputStream = null; try&amp;#123; String newBucket = bucketName; if(StrUtil.isNotEmpty(bucket))&amp;#123; newBucket = bucket; &amp;#125; initOSS(endPoint, accessKeyId, accessKeySecret); OSSObject ossObject = ossClient.getObject(newBucket,objectName); inputStream = new BufferedInputStream(ossObject.getObjectContent()); &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件获取失败\" + e.getMessage()); &amp;#125; return inputStream; &amp;#125; /** * 获取文件流 * @param objectName * @return */ public static InputStream getOssFile(String objectName)&amp;#123; return getOssFile(objectName,null); &amp;#125; /** * 获取文件外链 * @param bucketName * @param objectName * @param expires * @return */ public static String getObjectURL(String bucketName, String objectName, Date expires) &amp;#123; initOSS(endPoint, accessKeyId, accessKeySecret); try&amp;#123; if(ossClient.doesObjectExist(bucketName,objectName))&amp;#123; URL url = ossClient.generatePresignedUrl(bucketName,objectName,expires); return URLDecoder.decode(url.toString(),\"UTF-8\"); &amp;#125; &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件路径获取失败\" + e.getMessage()); &amp;#125; return null; &amp;#125; /** * 初始化 oss 客户端 * * @return */ private static OSSClient initOSS(String endpoint, String accessKeyId, String accessKeySecret) &amp;#123; if (ossClient == null) &amp;#123; ossClient = new OSSClient(endpoint, new DefaultCredentialProvider(accessKeyId, accessKeySecret), new ClientConfiguration()); &amp;#125; return ossClient; &amp;#125; /** * 上传文件到oss * @param stream * @param relativePath * @return */ public static String upload(InputStream stream, String relativePath) &amp;#123; String FILE_URL = null; String fileUrl = relativePath; initOSS(endPoint, accessKeyId, accessKeySecret); if (StrUtil.isNotEmpty(staticDomain) &amp;&amp; staticDomain.toLowerCase().startsWith(\"http\")) &amp;#123; FILE_URL = staticDomain + \"/\" + relativePath; &amp;#125; else &amp;#123; FILE_URL = \"https://\" + bucketName + \".\" + endPoint + \"/\" + fileUrl; &amp;#125; PutObjectResult result = ossClient.putObject(bucketName, fileUrl.toString(),stream); // 设置权限(公开读) ossClient.setBucketAcl(bucketName, CannedAccessControlList.PublicRead); if (result != null) &amp;#123; log.info(\"------OSS文件上传成功------\" + fileUrl); &amp;#125; return FILE_URL; &amp;#125; &amp;#125; 五、共同业务API: SysBaseApiImpl、ISysBaseAPI/** * @Description: 底层共通业务API，提供其他独立模块调用 * @Author: hfx * @Version:V1.0 */ @Slf4j @Service @Component public class SysBaseApiImpl implements ISysBaseAPI &amp;#123; /** 当前系统数据库类型 */ private static String DB_TYPE = \"\"; /** * minio桶名称 */ private static String miniBucketName; @Value(value = \"$&amp;#123;upload.minio.bucketName&amp;#125;\") public void setMiniBucketName(String miniBucketName) &amp;#123; SysBaseApiImpl.miniBucketName = miniBucketName; &amp;#125; private static String ossBucketName; @Value(value = \"$&amp;#123;upload.oss.bucketName&amp;#125;\") public void setOssBucketName(String ossBucketName) &amp;#123; SysBaseApiImpl.ossBucketName = ossBucketName; &amp;#125; @Override public String upload(MultipartFile file, String bizPath, String uploadType) &amp;#123; String url = \"\"; if(Constants.UPLOAD_TYPE_MINIO.equals(uploadType))&amp;#123; url = MinioUtil.upload(file,bizPath); &amp;#125;else&amp;#123; url = OssBootUtil.upload(file,bizPath); &amp;#125; return url; &amp;#125; @Override public String upload(MultipartFile file, String bizPath, String uploadType, String customBucket) &amp;#123; String url = \"\"; if(Constants.UPLOAD_TYPE_MINIO.equals(uploadType))&amp;#123; url = MinioUtil.upload(file,bizPath,customBucket); &amp;#125;else&amp;#123; url = OssBootUtil.upload(file,bizPath,customBucket); &amp;#125; return url; &amp;#125; @Override public void delImg(String delType, String delImgName) &amp;#123; try &amp;#123; if (Constants.UPLOAD_TYPE_MINIO.equals(delType))&amp;#123; MinioUtil.removeObject(miniBucketName, delImgName); &amp;#125;else &amp;#123; OssBootUtil.delete(delImgName); &amp;#125; &amp;#125;catch (Exception e)&amp;#123; log.info(\"文件删除失败\" + e.getMessage()); &amp;#125; &amp;#125; &amp;#125; /** * 底层共通业务API，提供其他独立模块调用 * @Author: hfx * @Version:V1.0 */ public interface ISysBaseAPI &amp;#123; /** * 文件上传 * @param file 文件 * @param bizPath 自定义路径 * @param uploadType 上传方式 * @return */ public String upload(MultipartFile file, String bizPath, String uploadType); /** * 文件上传 自定义桶 * @param file * @param bizPath * @param uploadType * @param customBucket * @return */ public String upload(MultipartFile file, String bizPath, String uploadType, String customBucket); /** * 文件删除 * @param delType * @param delImgName * @return */ public void delImg(String delType, String delImgName); &amp;#125; 六、删除图片请求类（body） 可以根据自己业务需求及前端传参方式，确定是否需要。 /** * 删除图片请求类 */ @Data public class DeleteQO &amp;#123; /** * 需要删除的图片 */ private List&lt;Object> preDelImg; /** * 删除的图片目录 */ private String relativePath; /** * 需要保存的图片 */ // private List&lt;String>preSaveImg; &amp;#125; 七：**.yml中的配置文件可参考如下：upload: # 本地：local\\Minio：minio\\阿里云：alioss uploadType: minio path : #文件上传根目录 设置 upload: C://img #阿里云oss存储配置 oss: # OSS endpoint 创建桶时根据区域选择的endpoint endpoint: oss-cn-beijing.aliyuncs.com accessKey: secretKey: # 阿里云桶名 bucketName: # 服务器设置的OSS访问域名 默认endpoint staticDomain: # minio文件上传 minio: # minio访问路径ip/域名(测试ip，正式环境请修改) minio_url: http:// # 账号 minio_name: # 密码 minio_pass: # minio桶名称 bucketName: 注意：以上代码个人为了做到以后的需求迭代，有点方法没有用到，请根据自己需求进行删减。以上代码如发现bug及不足，请留言……","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"redis中BitMap实现“用户签到”、“活跃用户”详解记录","slug":"redis中BitMap实现“用户签到”、“活跃用户”详解记录","date":"2020-07-15T13:18:08.000Z","updated":"2020-09-12T02:31:37.922Z","comments":true,"path":"2020/07/15/redis中BitMap实现“用户签到”、“活跃用户”详解记录/","link":"","permalink":"http://yoursite.com/2020/07/15/redis%E4%B8%ADBitMap%E5%AE%9E%E7%8E%B0%E2%80%9C%E7%94%A8%E6%88%B7%E7%AD%BE%E5%88%B0%E2%80%9D%E3%80%81%E2%80%9C%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E2%80%9D%E8%AF%A6%E8%A7%A3%E8%AE%B0%E5%BD%95/","excerpt":"","text":"redis中BitMap实现“用户签到”、“活跃用户”详解记录BitMap简介： BitMap是一串连续的二进制数字（0和1），类似于位数组，每一位所在的位置为偏移量（offset），类似于数组索引，BitMap就是通过最小的单位bit来进行0|1的设置，表示某个元素的值或者状态。所以BitMap比较适用于只有两种状态的场景。例如，统计每日活跃用户、统计每月打卡数(签到)等统计场景。1天记录1000W用户的活跃统计数据，只需要10000000/8/1024/1024 ≈1.2M。 优势 1.省空间：基于最小的单位bit进行存储。 2.时间复杂度：赋值-&gt;时间复杂度O(1)、读值-&gt;时间复杂度O(n)，操作是非常快的。 3.计算：二进制数据的存储，进行相关计算的时候非常快。 4.方便扩容 限制 redis中bit映射被限制在512MB之内，所以最大是2^32位。建议每个key的位数都控制下，因为读取时候时间复杂度O(n)，越大的串读的时间花销越多。 一、用户是否领取过优惠券：// redis客户端 Jedis jedis = new Jedis(); // 1.首先检验用户是否领取过优惠券 id:用户id ; couponId:优惠券id ;1:已领取，0：未领取 int isGot = jedis.getbit(couponId, id); if(isGot == 1)&amp;#123; // 已领取 return R.failed(\"您已经领取过此优惠券，不能重复领取！\"); &amp;#125;else&amp;#123; // 未领取 // 查询优惠券剩余数量 CouponEntity coupon = couponService.selectById(couponId); if(coupon.getNum() &lt;= 0)&amp;#123; return R.failed(\"您来晚了，优惠券已经领取完了！\"); &amp;#125; jedis.setbit(couponId, id, 1); // *如需要往数据库记录领取信息* // couponService.insert(); //减去优惠券剩余数量 couponService.deleteNum(couponId); return R.ok(\"已领取！\"); &amp;#125; // 2.统计已领取的优惠券数量 bitcount(key) Integer count = jedis.bitcount(couponId); 二、活跃用户统计// 当天登录及视为活跃 使用时间作为cacheKey，然后用户ID为offset，如果当日活跃过就设置为1 // 在登陆处添加 todayDate:当天时间 id：用户id // 获取当前日期 LocalDate now = LocalDate.now(); jedis.setbit(now, id, 1); // 统计当天活跃用户 jedis.bitcount(now); // 统计某个时间端活跃用户 date1 date2 or:取或 tem：返回值存在tem中，再bitcount计算结果 // AND：与 、OR：或 、NOT：非 、 XOR：异或 jedis.bitop(or, tem, date1, date2); int num = jedis.bitcount(tem); 三、用户签到： /** *譬如 setbit sign:123:1909 0 1 *代表用户ID=123签到，签到的时间是19年9月份，0代表该月第一天，1代表签到了 *第二天没有签到，无需处理，系统默认为0 */ // 获取当前年月日 LocalDate now = LocalDate.now(); int year = now.getYear(); int month = now.getMonthValue(); int day = now.getDayOfMonth(); String key = id+year+month; // 签到 int signIn = jedis.getbit(key, day); if(signIn == 1)&amp;#123; return R.faild(\"您已经签到了，一天只能签到一次！\");// 实际中可以通过前端点击签到按钮置灰，按钮只能点击一次。 &amp;#125;else&amp;#123; jedis.setbit(key, day, 1); &amp;#125; return R.ok(\"签到成功！\"); 以上代码记录紧急，仅供参考！如有错误及不严谨地方，请谅解并留言！","categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"Redis缓存穿透、缓存击穿、缓存雪崩","slug":"Redis缓存穿透、缓存击穿、缓存雪崩","date":"2020-07-08T13:18:08.000Z","updated":"2020-09-12T02:30:40.468Z","comments":true,"path":"2020/07/08/Redis缓存穿透、缓存击穿、缓存雪崩/","link":"","permalink":"http://yoursite.com/2020/07/08/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/","excerpt":"","text":"缓存穿透、缓存击穿、缓存雪崩：缓存穿透：描述：缓存穿透是指缓存和数据库中都查询不到数据。 问题及安全性：访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。如果有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 解决方案： 1、简单粗暴的方法，从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况下也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击； 2、采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤，（如果数据量较大，需要占用较大空间）。 3、拦截器，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截； 缓存击穿：描述：缓存击穿是指缓存中没有数据但数据库中有数据（一般是缓存时间到期）。 问题：如果并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。 解决方案： 1、设置热点数据永远不过期。 2、使用redis的分布式锁，即第一个请求去查询数据库并添加到缓存中，其后面的所有请求只需查询缓存无需查询数据库，从而减少数据库查询的巨大压力。 单机Redis实例: 多个Redis实例，请参阅Redlock算法 注意：1. 设置唯一锁名称防止误解锁；2. 需要设置锁的过期时间，防止死锁。 （1）redisTemplate实现（设置IfAbsent），无法实现可重入锁。 // 根据ID查询商品 @GetMapping(\"/&amp;#123;id&amp;#125;\") public R id(@PathVariable String id)&amp;#123; // 先查Redis缓存 Object o = redisTemplate.opsForValue().get(id); if (o != null) &amp;#123; // 命中缓存 System.err.println(\"id:\"+id+\",命中redis缓存...\"); return R.success(o); &amp;#125; // 缓存未命中 查询数据库 String lockKey = \"lock\" + id; // 加锁，10s后过期 for (;;) &amp;#123; if (redisTemplate.opsForValue().setIfAbsent(lockKey, System.currentTimeMillis(), 10L, TimeUnit.SECONDS)) &amp;#123; // 加锁成功的线程,再次检查 o = redisTemplate.opsForValue().get(id); if (o != null) &amp;#123; // 命中缓存 System.err.println(\"Thread:\" + Thread.currentThread().getName() + \",id:\"+id+\",命中redis缓存...\"); // 释放锁 redisTemplate.delete(lockKey); return R.success(o); &amp;#125; // 仍未命中 System.err.println(\"Thread:\" + Thread.currentThread().getName() + \",id:\" + id + \",查询DB...\"); Goods goods = goodsMapper.selectById(id); // 结果存入Redis redisTemplate.opsForValue().set(id, goods); // 释放锁 redisTemplate.delete(lockKey); return R.success(goods); &amp;#125; // 竞争不到锁，暂时让出CPU资源 Thread.yield(); &amp;#125; &amp;#125; （2）Redisson可实现可重入锁 @RestController public class RedisSonTest &amp;#123; @Autowired RedissonClient redissonClient;//实现分布式锁的 @Autowired RedisUtil redisUtil;//获得redis的链接 @GetMapping(value = \"/redissontest\") public String RedisSonTest()&amp;#123; Jedis jedis = redisUtil.getJedis(); RLock redisSonLock = redissonClient.getLock(\"redisSonLock\"); //加锁 redisSonLock.lock(10, TimeUnit.MINUTES);//有效期十分钟 String k = jedis.get(\"k\"); try &amp;#123; if(k==null)&amp;#123; k = \"1\"; &amp;#125; int inum = Integer.parseInt(k);//获得value的值 jedis.set(\"k\", inum+1+\"\");//value增加1 jedis.close(); &amp;#125;finally &amp;#123; // 解锁 redisSonLock.unlock(); &amp;#125; return k; &amp;#125; &amp;#125; 缓存雪崩：描述：redis中大量的热点数据缓存集体失效。 问题：当有大量请求的时候，就会导致这些请求全部发到数据库上，DB瞬时压力过重雪崩。 解决方案： 1、设置随机过期时间，避免同一时刻缓存大量失效。（当redis数据库崩溃的时候也会导致缓存雪崩） 2、使用google的Guava本地缓存，防止redis崩溃引起的雪崩。（JVM宕机后本地缓存会失效） 3、建立分布式集群： 将redis缓存分块存储到多台redis服务器上（防止单个redis崩溃导致缓存雪崩），这样就会减小缓存集体失效的概率。 4、设置热点数据永远不过期。","categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"java开发过程中常用的工具类","slug":"Java常用工具类","date":"2020-07-08T13:18:08.000Z","updated":"2020-09-12T02:25:20.299Z","comments":true,"path":"2020/07/08/Java常用工具类/","link":"","permalink":"http://yoursite.com/2020/07/08/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"工具类： java开发过程中常用的工具类，可以省去很多的无用功。如：MD5加密、String相关操作/判null，“”、集合操作等等…请前往一下网站查看，这里不做赘述。 官网地址：http://www.hutool.cn/","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"Mysql查询语句错误","slug":"Method queryTotal execution error of sql：SELECT COUNT(1)... ","date":"2020-06-22T12:18:02.000Z","updated":"2020-09-12T02:27:21.976Z","comments":true,"path":"2020/06/22/Method queryTotal execution error of sql：SELECT COUNT(1)... /","link":"","permalink":"http://yoursite.com/2020/06/22/Method%20queryTotal%20execution%20error%20of%20sql%EF%BC%9ASELECT%20COUNT(1)...%20/","excerpt":"","text":"Method queryTotal execution error of sql：SELECT COUNT(1)…场景：（查询语句）查询**详细信息。 问题分析及解决方案： -分析：查询执行时，将我们的目标查询语句（SELECT id,name…）执行成了SELECT COUNT(1)…。 这种问题一般是自己书写的SQL语句有问题，所以我们要首先定位到自己的SQL语句并仔细检查 -解决排查：一般SQL的错误点： 1、实体类中有code1字段表中没有（反之）。 2、查询字段名称与实体类或表中字段不对应。 3、查询的数据库及表不正确。（查错库和表） 4、SQL语句中的判空、判null、length&gt;0等操作是否严谨。 5、SQL语句是否书写有误等问题。 总结： 一般这种情况，都是SQL语句有错误，导致Mybaits查询不到相应的内容，从而执行了SELECT COUNT(1)…，所以务必要仔细检查SQL查询语句。","categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"百度富文本-Vue UEditor整合","slug":"百度富文本UEditor在vue中的整合","date":"2020-02-20T13:15:00.000Z","updated":"2020-09-12T08:15:43.163Z","comments":true,"path":"2020/02/20/百度富文本UEditor在vue中的整合/","link":"","permalink":"http://yoursite.com/2020/02/20/%E7%99%BE%E5%BA%A6%E5%AF%8C%E6%96%87%E6%9C%ACUEditor%E5%9C%A8vue%E4%B8%AD%E7%9A%84%E6%95%B4%E5%90%88/","excerpt":"","text":"百度富文本 vue UEditor 整合查看文档请转移至：百度富文本-Vue的整合","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"微信小程序 订阅消息","slug":"微信小程序-订阅消息","date":"2020-02-18T13:30:18.000Z","updated":"2020-09-12T02:40:24.850Z","comments":true,"path":"2020/02/18/微信小程序-订阅消息/","link":"","permalink":"http://yoursite.com/2020/02/18/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF/","excerpt":"","text":"微信小程序 订阅消息使用说明： 步骤一：获取模板 ID，登陆 微信公众平台 步骤二：发送消息用户必须授权。获取下发权限，详见小程序端消息订阅接口 wx.requestSubscribeMessage 步骤三： 1、拿到用户的opengId 2、获取access_token 3、调用接口下发订阅消息，详见服务端消息发送接口 subscribeMessage.send 一、发送模板消息所需字段： 二、必须获得access_token： 通俗的讲，access_token就是小程序官方给我们提供的一个凭证，你要调用小程序官方的接口，就必须先拿到access_token。 看下官方文档，可以知道我们需要用到下面的几个参数 获取access_token方法 @GetMapping(\"/getAccessToken\") public static String getAccessToken() &amp;#123; RestTemplate restTemplate = new RestTemplate(); Map&lt;String, String> params = new HashMap&lt;>(16); params.put(\"APPID\", \"wxc36f8fe5f4c70fa2\"); params.put(\"APPSECRET\", \"acc4380705c716611a7d1ff690ac21f0\"); ResponseEntity&lt;String> responseEntity = restTemplate.getForEntity( \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&amp;#123;APPID&amp;#125;&amp;secret=&amp;#123;APPSECRET&amp;#125;\", String.class, params); String body = responseEntity.getBody(); JSONObject object = JSON.parseObject(body); String Access_Token = object.getString(\"access_token\"); String expires_in = object.getString(\"expires_in\"); System.out.println(\"有效时长expires_in：\" + expires_in); return Access_Token; &amp;#125; 注意点：access_token，是存在有效期的 三、发送消息到小程序 推送代码： @RestController public class SendWxMessage &amp;#123; public static void main(String[] args) &amp;#123; String openid = \"o8MPr4oEWfgIM5IvMq9jZ2eUHA4g\"; SendWxMessage.push(openid); &amp;#125; /** * 发送订阅 * @return */ public static String push(String openid) &amp;#123; RestTemplate restTemplate = new RestTemplate(); // 这里简单起见我们每次都获取最新的access_token（时间开发中，应该在access_token快过期时再重新获取） String url = \"https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=\" + getAccessToken(); // 拼接推送的模版 WxMssVo wxMssVo = new WxMssVo(); // 用户的openid（要发送给那个用户，通常这里应该动态传进来的） wxMssVo.setTouser(openid); // 订阅消息模板id wxMssVo.setTemplate_id(\"W4TH5pcWj_UtPOhEYWmcvow2Xyyp3SNJyxyA39S9MO0\"); wxMssVo.setPage(\"pages/index/index\"); // 24小时制 Date date = new Date(); SimpleDateFormat format=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Map&lt;String, TemplateData> m = new HashMap&lt;>(16); // 以下所有的key名称必须与定义的模板的key名称相同 且value类型必须一致 m.put(\"thing1\", new TemplateData(\"小程序\")); m.put(\"time2\", new TemplateData(format.format(date))); m.put(\"thing4\", new TemplateData(\"888\")); m.put(\"number3\", new TemplateData(123.0)); wxMssVo.setData(m); ResponseEntity&lt;String> responseEntity = restTemplate.postForEntity(url, wxMssVo, String.class); return responseEntity.getBody(); &amp;#125; /** * 获取access_token */ @GetMapping(\"/getAccessToken\") public static String getAccessToken() &amp;#123; RestTemplate restTemplate = new RestTemplate(); Map&lt;String, String> params = new HashMap&lt;>(16); params.put(\"APPID\", \"wxc36f8fe5f4c70fa2\"); params.put(\"APPSECRET\", \"acc4380705c716611a7d1ff690ac21f0\"); ResponseEntity&lt;String> responseEntity = restTemplate.getForEntity( \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid= &amp;#123;APPID&amp;#125;&amp;secret=&amp;#123;APPSECRET&amp;#125;\", String.class, params); String body = responseEntity.getBody(); JSONObject object = JSON.parseObject(body); String Access_Token = object.getString(\"access_token\"); String expires_in = object.getString(\"expires_in\"); System.out.println(\"有效时长expires_in：\" + expires_in); return Access_Token; &amp;#125; &amp;#125; 注意点：Map&lt;String, TemplateData&gt;所有的key名称必须与定义的模板的key名称相同 且value类型必须一致 订阅消息参数值内容限制说明，文档里的参数值个数有12个 参考地址：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/subscribe-message/subscribeMessage.send.html 其余代码： WxMssVo类用来封装请求官方接口的参数 public class WxMssVo &amp;#123; private String touser;//用户openid private String template_id;//订阅消息模版id private String page = \"pages/index/index\";//默认跳到小程序首页 private Map&lt;String, TemplateData> data;//推送文字 public String getTouser() &amp;#123; return touser; &amp;#125; public void setTouser(String touser) &amp;#123; this.touser = touser; &amp;#125; public String getTemplate_id() &amp;#123; return template_id; &amp;#125; public void setTemplate_id(String template_id) &amp;#123; this.template_id = template_id; &amp;#125; public String getPage() &amp;#123; return page; &amp;#125; public void setPage(String page) &amp;#123; this.page = page; &amp;#125; public Map&lt;String, TemplateData> getData() &amp;#123; return data; &amp;#125; public void setData(Map&lt;String, TemplateData> data) &amp;#123; this.data = data; &amp;#125; &amp;#125; TemplateData类 用来定义消息的内容 public class TemplateData &amp;#123; private Object value; public TemplateData(Object value) &amp;#123; this.value = value; &amp;#125; public Object getValue() &amp;#123; return value; &amp;#125; public void setValue(Object value) &amp;#123; this.value = value; &amp;#125; &amp;#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"关于\"栈上分配\"和\"TLAB(Thread Local Allocation Buffer 即线程本地分配缓存)\"","slug":"栈上分配和TLAB","date":"2020-01-07T16:00:00.000Z","updated":"2020-09-12T03:49:59.574Z","comments":true,"path":"2020/01/08/栈上分配和TLAB/","link":"","permalink":"http://yoursite.com/2020/01/08/%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%92%8CTLAB/","excerpt":"","text":"栈上分配：为什么要栈上分配？ 在一个应用程序中，其实有很多的对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束。对于这种对象，如果分配在堆中，方法调用结束后就没有了引用指向这个对象，这种对象就是垃圾，等待GC回收，如果这种对象较多，无疑增加了GC的压力，所以JVM就提供了一种栈上分配。 开启逃逸分析： 如果一个对象想要在栈上分配，必须通过逃逸分析(-XX:+EliminateAllocations)。 逃逸分析的作用：分析对象的作用域是否会逃逸出方法之外，再server虚拟机模式下才可以开启（jdk1.6默认开启） 开启标量替换： (-XX:+EliminateAllocations) 标量替换的作用是允许将对象根据属性打散后分配再栈上，默认该配置为开启 可以通过配置 -XX:+PrintEscapeAnalysis 开启打印逃逸分析筛选结果 TLAB(Thread Local Allocation Buffer)什么是TLAB 全称叫做：Thread Local Allocation Buffer 即线程本地分配缓存 如何开启TLAB JVM默认开启了TLAB功能，也可以使用-XX: +UseTLAB 显示开启 如何观察TLAB使用情况 JVM提供了-XX:+PrintTLAB 参数打开跟踪TLAB的使用情况 如何调整TLAB默认大小 -XX:TLABSize 通过该参数指定分配给每一个线程的TLAB空间的大小 总结一下TLAB： 需要TLAB的原因就是提高对象在堆上的分配效率而采用的一种手段，就是给每个线程分配一小块私有的堆空间，即TLAB是一块线程私有的堆空间（实际上是Eden区中划出的） 栈上分配和TLAB对比 名称 针对点 处于对象分配流程的位置 栈上分配 避免GC无谓负担 1 TLAB 加速堆上对象的分配 2 对象分配流程图图片摘自实战Java虚拟机一书","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"二叉树、平衡二叉树、红黑树、B树、B+树","slug":"二叉树-平衡二叉树-红黑树-B树-B+树","date":"2019-12-20T13:13:48.000Z","updated":"2020-09-12T02:39:39.632Z","comments":true,"path":"2019/12/20/二叉树-平衡二叉树-红黑树-B树-B+树/","link":"","permalink":"http://yoursite.com/2019/12/20/%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91-B%E6%A0%91-B+%E6%A0%91/","excerpt":"​ 数据库中的数据一般是放在磁盘里面，存取数据的时候就要访问磁盘，物理访问过程：盘片旋转，磁臂移动 两个过程。盘片旋转到指定位置之后，移动磁臂开始进行数据的存取。如果使用顺序查找，查询数据的时候就要从头到尾查询一遍，如果所查询的数据靠近数据尾端，效率久会很低，当然，这种方式也是最低效率的。因此，出现了二叉树。","text":"​ 数据库中的数据一般是放在磁盘里面，存取数据的时候就要访问磁盘，物理访问过程：盘片旋转，磁臂移动 两个过程。盘片旋转到指定位置之后，移动磁臂开始进行数据的存取。如果使用顺序查找，查询数据的时候就要从头到尾查询一遍，如果所查询的数据靠近数据尾端，效率久会很低，当然，这种方式也是最低效率的。因此，出现了二叉树。 二叉树二叉树是一种非常重要的数据结构，它同时具有数组和链表各自的特点：它可以像数组一样快速查找，也可以像链表一样快速添加。但是它也有自己的缺点：删除操作复杂。 二叉树在插入数据时也存在一个很大的缺点： 在使用二叉树插入节点时：一个节点的左节点的关键值必须小于此节点，右节点必须大于或者等于此节点。 通过上面定义可以发现：如果插入的数据是有序的，二叉树就会形成一个分支的树结构，远远增加了树的深度。因而为了提高效率稳定性，形成了平衡二叉树： 平衡二叉树：平衡二叉树用平衡因子差值来判断是否平衡，并旋转二叉树。平衡因子：左右子树高度差。平衡二叉树里平衡因子不能超过1，否则旋转。缺点：平衡二叉树虽然达到了稳定，但是由于不停的旋转，时间方面浪费了很多，从而效率又降了下来。 那么怎样才能稳定的同时，旋转的次数少？ 再次升级–&gt;红黑树 红黑树：定义： 1、每个节点要么是红色，要么是黑色。 2、根节点必须是黑色。 3、红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。 4、对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。 红黑树旋转的关键逻辑是：确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。例如：节点A，左子树高度X，右子树高度Y， X-Y&lt;=min(X,Y);如果当 X-Y &gt; min(X,Y)，然后开始旋转。 在java中TreeSet的数据结构底层就是用的红黑树 红黑树虽然解决了稳定、时间浪费的问题，但是，我们一开始就说了，数据库中的数据一般是存在磁盘上的，如果考虑到磁盘IO的影响，当数据量过大，就有可能不能一次性读取到内存中；反复的从磁盘到内存，效率就又会降低！ 读取磁盘次数过多，读取浪费就太多，这也是MySql不使用红黑树作为索引的原因 B树多路存储能力 考虑到磁盘IO,内存的影响，所以产生了B树。B树：每个节点上都存有key和value，所以每次读取数据时，只需把相应的节点读取到内存中即可，而不需把整个树都读取到内存。等价于有关键字的二分查找，所以B树解决了红黑树存在的问题。 问题：B树虽然解决了磁盘读取到内存效率降低的问题，但是由于B树的每一个节点上都存有数据，那么就会造成空间浪费，范围查找还是没有解决。那应该怎么解决呢?再次升级–&gt;B+树！ B+树：B+树中所有的数据都存在叶子节点中，并且叶子节点中还加了指针形成了链表，其他的都是索引，增加了系统的稳定性以及遍历以及查找效率。 MySql索引采用B+树 为什么MySql中索引采用B+树？ 通过应用场景，我们可以知道。再通过MySql查询数据时，我们通常查询的不只是一条数据，大多数情况下都是多条数据。如果采用B树，查询多条时，可能需要跨层获取数据，所以，B+树中叶子节点之间增加了指针形成了链表结构，查询多条数据时更加的快速，因此MySql中索引采用了B+树，提高了效率！ hash比B+树更快，为什么MySql没有采用hash? 如果查询一条数据的话，hash确实比B+树快。但是正如我们上面所说，我们查询数据时通常是多条的，这时候由于B+树索引有序并且还有链表相连，而且数据库中的索引一般在磁盘，数据量大的时候，B+树可以允许数据分批，同时树的高度比较低，也提高了查询效率，所以多数据时B+树会更快。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]},{"title":"POI千万级导入-导出(excel)","slug":"POI千万级导入-导出Excel","date":"2019-11-20T13:18:08.000Z","updated":"2020-09-12T02:29:09.986Z","comments":true,"path":"2019/11/20/POI千万级导入-导出Excel/","link":"","permalink":"http://yoursite.com/2019/11/20/POI%E5%8D%83%E4%B8%87%E7%BA%A7%E5%AF%BC%E5%85%A5-%E5%AF%BC%E5%87%BAExcel/","excerpt":"","text":"POI千万级导入-导出(excel)前端采用LayUi框架 ，后端框架：SpringBoot 一 。 导出1.引入 &lt;dependency> &lt;groupId>org.apache.poi&lt;/groupId> &lt;artifactId>poi&lt;/artifactId> &lt;version>3.17&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.poi&lt;/groupId> &lt;artifactId>poi-ooxml&lt;/artifactId> &lt;version>3.17&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.poi&lt;/groupId> &lt;artifactId>poi-ooxml-schemas&lt;/artifactId> &lt;version>3.14&lt;/version> &lt;/dependency> 2.Controller代码 /** * 导出数据到Excel表格 * @param response * @param * @throws IOException */ @RequestMapping(value = \"export\") @ResponseBody public void export(HttpServletResponse response,GradeEntity gradeEntity) throws IOException &amp;#123; //查询数据 Integer id = gradeEntity.getId(); Map&lt;String ,Object> map = new HashMap&lt;>(); map.put(\"id\",id); List&lt;GradeEntity> gradeList = gradeService.selectLists(map); HSSFWorkbook wb = new HSSFWorkbook();//创建工作簿 HSSFWorkbook:Excel的文档对象 HSSFFont font = wb.createFont();//设置字体大小 为什么要用wb.createFont呢 因为wb是主 font是包含这个里面的 HSSFCellStyle style = wb.createCellStyle(); //设置单元格格式 style.setAlignment(HorizontalAlignment.CENTER);//居中对齐格式 style.setVerticalAlignment(VerticalAlignment.CENTER);//垂直居中 font.setFontHeightInPoints((short) 28);//设置字体 HSSFSheet sheet = wb.createSheet(\"等级信息表\");// //为每一列添加居中样式 sheet.setDefaultColumnStyle(0,style); sheet.setDefaultColumnStyle(1,style); sheet.setDefaultColumnStyle(2,style); sheet.setDefaultColumnStyle(3,style); sheet.setDefaultColumnStyle(4,style); sheet.setDefaultColumnStyle(5,style); sheet.setDefaultColumnStyle(6,style); HSSFRow row = null; //创建行 row = sheet.createRow(0);//创建第一行单元格.就像数组一样是0开头的 row.setHeight((short) (26.5 * 20));//设置行高 row.createCell(0).setCellValue(\"等级信息表\"); //设置第一行单元格设置值 HSSFPatriarch patr = sheet.createDrawingPatriarch();//HSSFPatriarch poi的划线方法 HSSFComment comment = patr.createComment(new HSSFClientAnchor(0, 0, 0, 0, (short) 4, 2, (short) 6, 5)); // 设置注释内容 comment.setString(new HSSFRichTextString(\"状态 0：关闭，1：开启！\")); //设置单元格合并 参数是：起始行号，终止行号， 起始列号，终止列号 CellRangeAddress rowRegion = new CellRangeAddress(0, 0, 0, 2); sheet.addMergedRegion(rowRegion); //sheet是页 这个的意思在文档Sheet的第一行 row = sheet.createRow(1); /* row.setHeight((short) (22.50 * 20));*/ //设置单元格格式 row.setHeight((short) (20.29 * 20)); //第一行标签 row.createCell(0).setCellValue(\"编号\"); row.createCell(1).setCellValue(\"等级名称\"); row.createCell(2).setCellValue(\"等级图标\"); row.createCell(3).setCellValue(\"等级值\"); row.createCell(4).setCellValue(\"等级\"); row.createCell(5).setCellValue(\"排序\"); row.createCell(6).setCellValue(\"状态\"); //遍历集合数据，产生数据行 for (int i = 0; i &lt; gradeList.size(); i++) &amp;#123; row = sheet.createRow(i + 2); GradeEntity grade = gradeList.get(i); //往表格添加数据 row.createCell(0).setCellValue(grade.getId()); row.createCell(1).setCellValue(grade.getName()); row.createCell(2).setCellValue(grade.getIcon()); row.createCell(3).setCellValue(grade.getIntegral()); row.createCell(4).setCellValue(grade.getGrade()); row.createCell(5).setCellValue(grade.getSort()); row.createCell(6).setCellValue(grade.getStatus()); //日期格式化 /* SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String time = sdf.format(userInfo1.getCreateDate()); row.createCell(6).setCellValue(time);*/ //状态处理 数据库存放的是0,1 我写的麻烦 你们自己处理吧 Integer status = grade.getStatus(); String status1 = null; if (status == 0) &amp;#123; status1 = \"关闭\"; row.createCell(6).setCellValue(status1); &amp;#125; else &amp;#123; row.createCell(6).setCellValue(\"开启\"); &amp;#125; &amp;#125; sheet.setDefaultRowHeight((short) (20.29 * 20)); for (int i = 0; i &lt;= 6; i++) &amp;#123; sheet.autoSizeColumn(i);//自动行高 &amp;#125; response.setContentType(\"UTF-8\"); //设置格式为UTF-8 不然可能会乱码 response.setContentType(\"application/vnd.ms-excel;charset=utf-8\"); //output流得到流 OutputStream os = response.getOutputStream(); String fileName = \"用户报名信息\";//导出得文件名字 String downloadFileName=new String(fileName.getBytes(\"utf-8\"),\"iso8859-1\"); response.setHeader(\"Content-Disposition\", \"attachment;filename=\"+downloadFileName+\".xls\"); wb.write(os); os.flush();//刷新流 os.close();//关闭流 &amp;#125; 3.layui前端按钮（其他按钮自定） &lt;script type=\"text/html\" id=\"tableBar\"> @if(shiro.hasPermission(\"/grade/update\"))&amp;#123; &lt;a class=\"layui-btn layui-btn-primary layui-btn-xs\" lay-event=\"edit\">修改&lt;/a> @&amp;#125; @if(shiro.hasPermission(\"/grade/delete\"))&amp;#123; &lt;a class=\"layui-btn layui-btn-danger layui-btn-xs\" lay-event=\"delete\">删除&lt;/a> @&amp;#125; &lt;a class=\"layui-btn layui-btn-danger layui-btn-xs\" lay-event=\"export\" href=\"/grade/export\" >导出&lt;/a> &lt;/script> @&amp;#125; 二.导入Excel 到数据库—————-Controller代码： /** * 导入数据到数据库 * * @param request * @param * @throws IOException */ @RequestMapping(value = \"/import\") @ResponseBody public GradeEntity imports(MultipartFile file, HttpServletRequest request) throws IOException &amp;#123; GradeEntity grade= new GradeEntity(); try &amp;#123; /*List&lt;GradeEntity> typeLists = new ArrayList&lt;GradeEntity>();*/ //使用POI解析Excel文件 //如果是xls，使用HSSFWorkbook；2003年的excel 如果是xlsx，使用XSSFWorkbook 2007年excel HSSFWorkbook workbook = new HSSFWorkbook(file.getInputStream()); //前台传过来的文件 /*HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(ResourceUtils.getFile(\"F:/import.xls\")));*/ //写死的路径 //根据名称获得指定Sheet对象 HSSFSheet hssfSheet = workbook.getSheetAt(0); for (Row row : hssfSheet) &amp;#123; int rowNum = row.getRowNum(); if (rowNum == 0) &amp;#123;//跳出第一行 一般第一行都是表头没有数据意义 continue; &amp;#125; //编号 if (row.getCell(0) != null) &amp;#123;//第1列数据 row.getCell(0).setCellType(CellType.STRING); grade.setId(Integer.parseInt(row.getCell(0).getStringCellValue())); &amp;#125; //等级名称 if (row.getCell(1) != null) &amp;#123;//第2列 row.getCell(1).setCellType(CellType.STRING); grade.setName(row.getCell(1).getStringCellValue()); &amp;#125; //等级图标 if (row.getCell(2) != null) &amp;#123;//第3列 row.getCell(2).setCellType(CellType.STRING); grade.setIcon(row.getCell(2).getStringCellValue()); &amp;#125; //等级值 // 转换为Integer类 if (row.getCell(3) != null) &amp;#123;//第4列 row.getCell(3).setCellType(CellType.STRING); grade.setIntegral(Integer.parseInt(row.getCell(3).getStringCellValue())); &amp;#125; /*// 转换为日期类型 if(row.getCell(4)!=null)&amp;#123;//第5列 row.getCell(4).setCellType(Cell.CELL_TYPE_NUMERIC); grade.setAddtime( HSSFDateUtil.getJavaDate(row.getCell(4).getNumericCellValue())); &amp;#125;*/ //等级 if (row.getCell(4) != null) &amp;#123;//第5列 row.getCell(4).setCellType(CellType.STRING); grade.setGrade(Integer.parseInt(row.getCell(4).getStringCellValue())); &amp;#125; //排序 if (row.getCell(5) != null) &amp;#123;//第6列 row.getCell(5).setCellType(CellType.STRING); grade.setSort(Integer.parseInt(row.getCell(5).getStringCellValue())); &amp;#125; //状态 if (row.getCell(6) != null) &amp;#123;//第7列 row.getCell(6).setCellType(CellType.STRING); if (\"开启\".equals(grade.getSort())) &amp;#123; grade.setStatus(1); &amp;#125; else &amp;#123; grade.setStatus(0); &amp;#125; &amp;#125; /* typeLists.add(grade);*/ //调用service执行保存typeLists的方法 gradeService.insert(grade);//添加每一条数据 &amp;#125; &amp;#125; catch (Exception e) &amp;#123; e.printStackTrace(); &amp;#125; return grade;//使用layui前端上传文件 所以需要返回一个值（也可不返回，依照前端而定） &amp;#125; ———-layui前端实现：JS代码： //导入Excel upload.render(&amp;#123; elem: '#import' , url: \"/grade/import\" ,accept: 'file' ,exts: 'xls|xlsx' //只允许上传Excel文件 ,done: function(res)&amp;#123; alert(\"导入成功！\") //刷新表格 tableResult.reload(); &amp;#125; &amp;#125;); HTMl代码： &lt;div class=\" layui-upload\"> &lt;button type=\"button\" class=\"layui-btn layui-btn-normal\" id=\"import\">导入&lt;/button>&lt;!--导入Excel--> &lt;/div>","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]}],"categories":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/categories/DB/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E6%A0%88/"}]}